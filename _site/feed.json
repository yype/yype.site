{
    "version": "https://jsonfeed.org/version/1",
    "title": "yype.site",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "hacking & exploring",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author": "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}",
    
"items": [
    
        {
            "id": "http://localhost:4000/2020/10/23/n1vault",
            "title": "N1CTF2020 n1vault, thoughts & solutions",
            "summary": null,
            "content_text": "IntroI designed the RE challenge n1vault in the recent CTF N1CTF2020, in this post I will talk about details about this chal and offer some possible solutions.The core part of this challenge is to craft a file’s CRC to an arbitrary value(zero) by modifying some specified bytes of the same bit size as the CRC value.As for the binary n1vault, it uses SHA256 to digest all the bytes inside the file(credencial.png) except for the even bytes in the last 25 bytes(some twists were added to the sha256_update function, paving the way for the backdoor), once the file’s CRC has been faked to 0, a secret logic(backdoor) will be triggered by an exception FPE_INTDIV, since the verification inside function main has an unnecessary comparison 4764888639493207598 / (crc32_result | crc64_result) == 1, which will trigger an FPE_INTDIV when both crc32_result and crc64_result are zero, and will be evaluated to true when given the original file credential.png. Players’ job is to to craft an input to trigger the backdoor, send the crafted bytes to the judging bot and receive the flag.SolutionThe reverse engineering part of the binary program is quite easy, some junks with fixed patterns are inserted into the main logic, which can be bypassed by simple searching &amp; replacing. After that the program logic is really straightforward, we only have to solve the math problem left.CRC has a property that the final result can be viewed as the linear combination of the influence of each bit in the message and an initial bias, based on $GF(2)$, which can be described as:\\(f(x)=f(0) + \\sum_{i=0}^{CRC\\_SIZE-1} x_i \\cdot \\mbox{influence}(i),\\)where $f(0)$ is the initial bias, specifically for this challenge, is the CRC of the credential with all the even bytes in the last 25 bytes set to zero. Given this property, if we have enough $x_i$ to control, we can easily construct a matrix and solve each $x_i$ using gauss elimination. The twist here is that we have to ensure both $f(x)=CRC32(credential)$ and $g(x)=CRC64(credential)$ are equal to zero. Actually if we let $h(x)=(f(x) &lt; &lt; 64)+g(x)$ and focus our attention on making $h(x)=0$, it has the same effect as making both $f(x)$ and $g(x)$ zero.I write a tool based on this interesting property of CRC, allowing us to arbitrarily craft a file’s CRC by specifying certain bits available for modification. It can output all the available solutions and allows for fewer available bits than the bit size of the CRC result. You can check the tool here:  https://github.com/yype/crcolliderUsing this tool we can easily solve the problem using the following Python code:from crcollider import collcrcfrom crc_funcs import crc64, crc32def crc96(m):    return (crc32(m) &lt;&lt; 64) + crc64(m)def solve_chal():    with open('credential.png', 'rb') as f:        org_img = f.read()    rg = list(range(len(org_img)*8))    available_bits = []    for i in range(12):        # even bytes in the last 25 bytes        available_bits += rg[len(rg)-16*i-16:len(rg)-16*i-8]    sol_num, sols = collcrc(crc96, 96, org_img, available_bits, 0x0)        print(f'{sol_num} solution(s) found')    for i, each in enumerate(sols):        file_out = f'credential_sol{i}.png'        print(f'Outputting sol{i} to {file_out}...')        with open(file_out, 'wb') as f:            f.write(each)if __name__ == '__main__':    solve_chal()There are totally 4 solutions available for this challenge. One of them contains only visible characters, which is n1vaultadmin(intentionally crafted), while others are not. It might be better if I put some constraints to ensure that only one solution is available though.solution&gt; python3 .\\main.py4 solution(s) foundOutputting sol0 to credential_sol0.png...Outputting sol1 to credential_sol1.png...Outputting sol2 to credential_sol2.png...Outputting sol3 to credential_sol3.png...You can also check the awesome write-up from team Super Guesser who got the first blood of this challenge here: https://gist.github.com/jhs7jhs/cb5fedc1ffb6138b73420cb8567357bb#n1vault.The source code of this challenge and a duplicate of this post are uploaded to GitHub, check them out at: https://github.com/Nu1LCTF/n1ctf-2020/tree/main/RE/n1vault.",
            "content_html": "<h2 id=\"intro\">Intro</h2><p>I designed the RE challenge <em>n1vault</em> in the recent CTF <a href=\"https://ctftime.org/event/1099\" target=\"_blank\">N1CTF2020</a>, in this post I will talk about details about this chal and offer some possible solutions.</p><p>The core part of this challenge is to craft a file’s CRC to an arbitrary value(zero) by modifying some specified bytes of the same bit size as the CRC value.</p><p>As for the binary <code>n1vault</code>, it uses SHA256 to digest all the bytes inside the file(<code>credencial.png</code>) except for the even bytes in the last 25 bytes(some twists were added to the <em>sha256_update</em> function, paving the way for the backdoor), once the file’s CRC has been faked to 0, a secret logic(backdoor) will be triggered by an exception <em>FPE_INTDIV</em>, since the verification inside function <code>main</code> has an unnecessary comparison <code>4764888639493207598 / (crc32_result | crc64_result) == 1</code>, which will trigger an <em>FPE_INTDIV</em> when both crc32_result and crc64_result are zero, and will be evaluated to <em>true</em> when given the original file <code>credential.png</code>. Players’ job is to to craft an input to trigger the backdoor, send the crafted bytes to the judging bot and receive the flag.</p><h2 id=\"solution\">Solution</h2><p>The reverse engineering part of the binary program is quite easy, some junks with fixed patterns are inserted into the main logic, which can be bypassed by simple searching &amp; replacing. After that the program logic is really straightforward, we only have to solve the math problem left.</p><p>CRC has a property that the final result can be viewed as the linear combination of the influence of each bit in the message and an initial bias, based on $GF(2)$, which can be described as:\\(f(x)=f(0) + \\sum_{i=0}^{CRC\\_SIZE-1} x_i \\cdot \\mbox{influence}(i),\\)where $f(0)$ is the initial bias, specifically for this challenge, is the CRC of the credential with all the even bytes in the last 25 bytes set to zero. Given this property, if we have enough $x_i$ to control, we can easily construct a matrix and solve each $x_i$ using gauss elimination. The twist here is that we have to ensure both $f(x)=CRC32(credential)$ and $g(x)=CRC64(credential)$ are equal to zero. Actually if we let $h(x)=(f(x) &lt; &lt; 64)+g(x)$ and focus our attention on making $h(x)=0$, it has the same effect as making both $f(x)$ and $g(x)$ zero.</p><p>I write a tool based on this interesting property of CRC, allowing us to arbitrarily craft a file’s CRC by specifying certain bits available for modification. It can output all the available solutions and allows for fewer available bits than the bit size of the CRC result. You can check the tool here:</p><blockquote>  <p><a href=\"https://github.com/yype/crcollider\" target=\"_blank\">https://github.com/yype/crcollider</a></p></blockquote><p>Using this tool we can easily solve the problem using the following Python code:</p><pre><code class=\"language-python\">from crcollider import collcrcfrom crc_funcs import crc64, crc32def crc96(m):    return (crc32(m) &lt;&lt; 64) + crc64(m)def solve_chal():    with open('credential.png', 'rb') as f:        org_img = f.read()    rg = list(range(len(org_img)*8))    available_bits = []    for i in range(12):        # even bytes in the last 25 bytes        available_bits += rg[len(rg)-16*i-16:len(rg)-16*i-8]    sol_num, sols = collcrc(crc96, 96, org_img, available_bits, 0x0)        print(f'{sol_num} solution(s) found')    for i, each in enumerate(sols):        file_out = f'credential_sol{i}.png'        print(f'Outputting sol{i} to {file_out}...')        with open(file_out, 'wb') as f:            f.write(each)if __name__ == '__main__':    solve_chal()</code></pre><p>There are totally 4 solutions available for this challenge. One of them contains only visible characters, which is <code>n1vaultadmin</code>(intentionally crafted), while others are not. It might be better if I put some constraints to ensure that only one solution is available though.</p><pre><code>solution&gt; python3 .\\main.py4 solution(s) foundOutputting sol0 to credential_sol0.png...Outputting sol1 to credential_sol1.png...Outputting sol2 to credential_sol2.png...Outputting sol3 to credential_sol3.png...</code></pre><p>You can also check the awesome write-up from team <em>Super Guesser</em> who got the first blood of this challenge here: <a href=\"https://gist.github.com/jhs7jhs/cb5fedc1ffb6138b73420cb8567357bb#n1vault\" target=\"_blank\">https://gist.github.com/jhs7jhs/cb5fedc1ffb6138b73420cb8567357bb#n1vault</a>.</p><p>The source code of this challenge and a duplicate of this post are uploaded to GitHub, check them out at: <a href=\"https://github.com/Nu1LCTF/n1ctf-2020/tree/main/RE/n1vault\" target=\"_blank\">https://github.com/Nu1LCTF/n1ctf-2020/tree/main/RE/n1vault</a>.</p>",
            "url": "http://localhost:4000/2020/10/23/n1vault",
            
            
            
            "tags": ["CTF","Reverse Engineering","N1CTF2020"],
            
            "date_published": "2020-10-23T00:00:00+08:00",
            "date_modified": "2020-10-23T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/04/20/hypercard-over-windows",
            "title": "PlaidCTF2020 The Watness 2 Write-up",
            "summary": null,
            "content_text": "IntroRecently in PlaidCTF2020 there was a RE challenge called The Watness 2, which is a game that requires the application HyperCard to run. Since I did not have a Macbook computer, I’d been struggling figuring out ways to run this game over my Windows 10 laptop. Here is how I finally managed to do that.Steps  Follow this great video tutorial  Download StuffitExpander, add it to the volumes’ list, install it inside the VM:  Download HyperCard 2.4, install it inside the VM as described above  Extract the .rc1 file from the .sit file and open it with a simple double-click:Challenge SolutionExtract the stack’s script code:on openCard  Send colorMe to this card  pass openCardend openCardon closeCard  global prev_card  get the id of this cd  put it into prev_card  lock screen  pass closeCardend closeCardon colorMe  AddColor colorCard,stamp,0end colorMeon openStack  AddColor install  setupMenu  go to card \"tun-1-n\"  pass openStackend openStackon closeStack  AddColor remove  pass closeStackend closeStackon genPuzzle  send \"doMenu New Button\" to Hypercardend genPuzzleon initCard  answer prev_cardend initCardon menuReset  setupMenu  pass menuResetend menuReseton setupMenu  if there is not a menu \"Watness\" then    create menu \"Watness\"    put \"Generate Puzzle\"&amp;return&amp;\"Init Card\"&amp;return&amp;\"Set up Nav\"&amp;return&amp;\"Create Puzzle\" into menu \"Watness\" with menuMsg genPuzzle,initCard,setupNav,constructPuzzle  end ifend setupMenuon setupNav  ask \"What is the name of this card\"  set name of this cd to it    ask \"Where should the left go?\"  put it into left_loc  send \"doMenu New Button\" to Hypercard  set height of the last button to 342  set width of the last button to 100  set topleft of the last button to \"0,0\"  set style of the last button to \"transparent\"  set name of the last button to \"\"  put \"on mouseUp\"&amp;return&amp;\"go to card \"&amp;quote&amp;\"\"&amp;left_loc&amp;quote&amp;return&amp;\"end mouseUp\" into left_script  set script of last button to left_script    ask \"Where should the right go?\"  put it into right_loc  send \"doMenu New Button\" to Hypercard  set height of the last button to 342  set width of the last button to 100  set topleft of the last button to \"412,0\"  set style of the last button to \"transparent\"  set name of the last button to \"\"  put \"on mouseUp\"&amp;return&amp;\"go to card \"&amp;quote&amp;\"\"&amp;right_loc&amp;quote&amp;return&amp;\"end mouseUp\" into right_script  set script of last button to right_script    ask \"Where should fwd go?\"  put it into fwd_loc  send \"doMenu New Button\" to Hypercard  set height of the last button to 342  set width of the last button to 311  set the top of the last button to 0  set the left of the last button to 100  set style of the last button to \"transparent\"  set name of the last button to \"\"  put \"on mouseUp\"&amp;return&amp;\"go to card \"&amp;quote&amp;\"\"&amp;fwd_loc&amp;quote&amp;return&amp;\"end mouseUp\" into fwd_script  set script of last button to fwd_script    get the script of this card  put it into cd_script  put cd_script&amp;return into cd_script  put cd_script&amp;\"on arrowKey key\"&amp;return into cd_script  put cd_script&amp;\" if key = \"&amp;quote&amp;\"left\"&amp;quote&amp;\"then\"&amp;return into cd_script  put cd_script&amp;\"  go to cd \"&amp;quote&amp;left_loc&amp;quote&amp;return into cd_script  put cd_script&amp;\" end if\"&amp;return into cd_script  put cd_script&amp;\" if key = \"&amp;quote&amp;\"right\"&amp;quote&amp;\"then\"&amp;return into cd_script  put cd_script&amp;\"  go to cd \"&amp;quote&amp;right_loc&amp;quote&amp;return into cd_script  put cd_script&amp;\" end if\"&amp;return into cd_script  put cd_script&amp;\" if key = \"&amp;quote&amp;\"up\"&amp;quote&amp;\"then\"&amp;return into cd_script  put cd_script&amp;\"  go to cd \"&amp;quote&amp;fwd_loc&amp;quote&amp;return into cd_script  put cd_script&amp;\" end if\"&amp;return into cd_script  put cd_script&amp;\"end arrowKey\"&amp;return into cd_script      set the script of this cd to cd_scriptend setupNavon makeNode  global node  send \"doMenu New Button\" to Hypercard  put the id of the last button into nodeend makeNodeon constructPuzzle  global node,constraints    ask \"What are the constraints\"  put it into constraints    get the script of this cd  put it into cd_script  put cd_script&amp;return into cd_script  put cd_script&amp;\"on openCard\"&amp;return into cd_script  put cd_script&amp;\"  global constraints,path,cursor_x,cursor_y,\" into cd_script    put 0 into i  repeat for 8        put 0 into j    repeat for 8      put cd_script&amp;\"active_\"&amp;i&amp;\"_\"&amp;j&amp;\",\" into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put cd_script&amp;\"dummy\"&amp;return into cd_script  put cd_script&amp;\"  colorme\"&amp;return into cd_script  put cd_script&amp;\"  put -1 into cursor_x\"&amp;return into cd_script  put cd_script&amp;\"  put 0 into cursor_y\"&amp;return into cd_script  put cd_script&amp;\"  put \"&amp;quote&amp;quote&amp;\" into path\"&amp;return into cd_script  put cd_script&amp;\"  put \"&amp;quote&amp;constraints&amp;quote&amp;\" into constraints\"&amp;return into cd_script    put 1 into c_i  put 0 into i  repeat for 7        put 0 into j    repeat for 7      get char (j*7+i+1) of constraints      put it into letter            if letter &lt;&gt; \" \" then        makeNode                set the width of button id node to 10        set the height of button id node to 10                set the top of button id node to (76 + j * 30)        set the left of button id node to (161 + i * 30)                set the style of button id node to \"opaque\"        set showName of button id node to false                if letter = \"r\" then          put \"65535,0,0\" into node_color        end if        if letter = \"g\" then          put \"0,65535,0\" into node_color        end if        if letter = \"b\" then          put \"0,0,65535\" into node_color        end if                if letter &lt;&gt; \" \" then          addColor colorButton, cd, node, node_color                    put cd_script&amp;\"  addColor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;node_color&amp;quote&amp;return into cd_script        end if      end if                        put j+1 into j    end repeat        put i+1 into i  end repeat        put 0 into i  repeat for 8        put 0 into j    repeat for 8      put cd_script&amp;\"  put \"&amp;quote&amp;quote&amp;\" into active_\"&amp;i&amp;\"_\"&amp;j&amp;return into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    makeNode    set the width of button id node to 10  set the height of button id node to 15  set the left of button id node to 356  set the top of button id node to 276  set the name of button id node to \"path_extension\"  set showName of button id node to false  set the style of button id node to opaque  addcolor colorButton, cd, node, \"37632,30208,12288\"    put \"\" into node_script  put node_script&amp;\"on checkYoSelf\"&amp;return into node_script  put node_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script  put node_script&amp;\"end checkYoSelf\"&amp;return into node_script    set the script of button id node to node_script    put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script      makeNode    set the width of button id node to 10  set the height of button id node to 10  set the left of button id node to 356  set the top of button id node to 286  set the name of button id node to \"finale\"  set showName of button id node to false  set the style of button id node to oval  addcolor colorButton, cd, node, \"37632,30208,12288\"    put \"\" into node_script  put node_script&amp;\"on mouseUp\"&amp;return into node_script  put node_script&amp;\"  global cursor_x, cursor_y\"&amp;return into node_script  put node_script&amp;\"  if (cursor_x = 7) and (cursor_y = 7) then\"&amp;return into node_script  put node_script&amp;\"    addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script  put node_script&amp;\"    send \"&amp;quote&amp;\"checkYoSelf\"&amp;quote&amp;\" to button path_extension\"&amp;return into node_script  put node_script&amp;\"    send \"&amp;quote&amp;\"checkSolution\"&amp;quote&amp;\" to this cd\"&amp;return into node_script  put node_script&amp;\"  end if\"&amp;return into node_script  put node_script&amp;\"end mouseUp\"&amp;return into node_script    set the script of button id node to node_script    put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script    put 0 into i  repeat for 7        put 0 into j    repeat for 8      makeNode            set the width of button id node to 30      set the height of button id node to 10            set the top of button id node to (61 + 30 * j)      set the left of button id node to (151 + 30 * i)            set the style of button id node to opaque      set the name of button id node to \"h_path_\"&amp;i&amp;\"_\"&amp;j            set showName of button id node to false            addcolor colorButton, cd, node, \"37632,30208,12288\"            put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script            get the script of button id node      put it into node_script            put \"active_\"&amp;i&amp;\"_\"&amp;j into f_node      put \"active_\"&amp;(i+1)&amp;\"_\"&amp;j into s_node            put node_script&amp;return into node_script      put node_script&amp;\"on checkYoSelf\"&amp;return into node_script      put node_script&amp;\"  global \"&amp;f_node&amp;\",\"&amp;s_node&amp;return into node_script      put node_script&amp;\"  if (\"&amp;f_node&amp;\" = true) and (\"&amp;s_node&amp;\" = true) then\"&amp;return into node_script      put node_script&amp;\"    addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script      put node_script&amp;\"  end if\"&amp;return into node_script      put node_script&amp;\"end checkYoSelf\"&amp;return into node_script            set the script of button id node to node_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put 0 into i  repeat for 8        put 0 into j    repeat for 7      makeNode            set the width of button id node to 10      set the height of button id node to 30            set the top of button id node to (66 + 30 * j)      set the left of button id node to (146 + 30 * i)            set the style of button id node to opaque      set the name of button id node to \"v_path_\"&amp;i&amp;\"_\"&amp;j            set showName of button id node to false            addcolor colorButton, cd, node, \"37632,30208,12288\"            put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script            get the script of button id node      put it into node_script            put \"active_\"&amp;i&amp;\"_\"&amp;j into f_node      put \"active_\"&amp;i&amp;\"_\"&amp;(j+1) into s_node            put node_script&amp;return into node_script      put node_script&amp;\"on checkYoSelf\"&amp;return into node_script      put node_script&amp;\"  global \"&amp;f_node&amp;\",\"&amp;s_node&amp;return into node_script      put node_script&amp;\"  if (\"&amp;f_node&amp;\" = true) and (\"&amp;s_node&amp;\" = true) then\"&amp;return into node_script      put node_script&amp;\"    addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script      put node_script&amp;\"  end if\"&amp;return into node_script      put node_script&amp;\"end checkYoSelf\"&amp;return into node_script            set the script of button id node to node_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put 0 into i  repeat for 8        put 0 into j    repeat for 8      makeNode            set the width of button id node to 10      set the height of button id node to 10            set the top of button id node to (61 + 30 * j)      set the left of button id node to (146 + 30 * i)            set the style of button id node to oval      set the name of button id node to \"button_\"&amp;i&amp;\"_\"&amp;j            set showName of button id node to false            addcolor colorButton, cd, node, \"37632,30208,12288\"            put \"active_\"&amp;i&amp;\"_\"&amp;j into v_name            put \"\" into node_script      put node_script&amp;\"on mouseUp\"&amp;return into node_script      put node_script&amp;\"  global \"&amp;v_name&amp;\",cursor_x,cursor_y\"&amp;return into node_script      put node_script&amp;\"  put cursor_x into prev_x\"&amp;return into node_script      put node_script&amp;\"  put cursor_y into prev_y\"&amp;return into node_script      put node_script&amp;\"  put abs(cursor_x-\"&amp;i&amp;\") into dx\"&amp;return into node_script      put node_script&amp;\"  put abs(cursor_y-\"&amp;j&amp;\") into dy\"&amp;return into node_script      put node_script&amp;\"  if (\"&amp;v_name&amp;\" = \"&amp;quote&amp;quote&amp;\") and ((dx = 1 and dy = 0) or (dx = 0 and dy = 1)) then\"&amp;return into node_script      put node_script&amp;\"    put true into \"&amp;v_name&amp;return into node_script      put node_script&amp;\"    send \"&amp;quote&amp;\"updateState \"&amp;i&amp;\",\"&amp;j&amp;quote&amp;\" to this cd\"&amp;return into node_script      put node_script&amp;\"    addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script      put node_script&amp;\"  end if\"&amp;return into node_script      put node_script&amp;\"end mouseUp\"&amp;return into node_script            set the script of button id node to node_script            put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    set the width of button button_0_0 to 30  set the height of button button_0_0 to 30    set the top of button button_0_0 to 51  set the left of button button_0_0 to 136    get the id of button button_0_0  addColor colorButton, cd, it, \"37632,30208,12288\"    put cd_script&amp;\"end openCard\"&amp;return into cd_script  set the script of this cd to cd_script  end constructPuzzleon checkSolution  global puzzle_id,path,constraints,flag_1,flag_2,flag_3  watnesssolver constraints,path  put the result into success  if success = \"true\" then    if puzzle_id = 1 then      decoder path,\"clrtffxpry\"      put the result into flag_1    end if    if puzzle_id = 2 then      decoder path,\"nyghq7xksg\"      put the result into flag_2    end if    if puzzle_id = 3 then      decoder path,\"ppyyvn}1{7\"      put the result into flag_3    end if  else    send opencard to this cd  end ifend checkSolutionon updateState i,j  global path,cursor_x,cursor_y    if (i &lt;&gt; 0) or (j &lt;&gt; 0) then    if (cursor_y = j+1) and (cursor_x = i) then      put path&amp;\"U\" into path    end if    if (cursor_y = j) and (cursor_x = i - 1) then      put path&amp;\"R\" into path    end if    if (cursor_y = j-1) and (cursor_x = i) then      put path&amp;\"D\" into path    end if    if (cursor_y = j) and (cursor_x = i + 1) then      put path&amp;\"L\" into path    end if  end if      if cursor_x &gt;= 0 and cursor_y &gt;= 0 then    put \"h_path_\"&amp;min(cursor_x, i)&amp;\"_\"&amp;min(cursor_y, j) into h_path    put \"v_path_\"&amp;min(cursor_x, i)&amp;\"_\"&amp;min(cursor_y, j) into v_path        if i = cursor_x then      send checkYoSelf to button v_path    end if        if j = cursor_y then      send checkYoSelf to button h_path    end if      end if    put i into cursor_x  put j into cursor_yend updateStateThe card’s script code can also be extracted (puzzle 1):on openCard  global puzzle_id,constraints,path,cursor_x,cursor_y,active_0_0,active_0_1,active_0_2,active_0_3,active_0_4,active_0_5,active_0_6,active_0_7,active_1_0,active_1_1,active_1_2,active_1_3,active_1_4,active_1_5,active_1_6,active_1_7,active_2_0,active_2_1,active_2_2,active_2_3,active_2_4,active_2_5,active_2_6,active_2_7,active_3_0,active_3_1,active_3_2,active_3_3,active_3_4,active_3_5,active_3_6,active_3_7,active_4_0,active_4_1,active_4_2,active_4_3,active_4_4,active_4_5,active_4_6,active_4_7,active_5_0,active_5_1,active_5_2,active_5_3,active_5_4,active_5_5,active_5_6,active_5_7,active_6_0,active_6_1,active_6_2,active_6_3,active_6_4,active_6_5,active_6_6,active_6_7,active_7_0,active_7_1,active_7_2,active_7_3,active_7_4,active_7_5,active_7_6,active_7_7,dummy  colorme  put 1 into puzzle_id  put -1 into cursor_x  put 0 into cursor_y  put \"\" into path  put \"rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg\" into constraints  addColor colorButton, cd, 1, \"65535,0,0\"  ...end openCardon arrowKey key  if key = \"left\"then    go to cd \"entry-3-n\"  end if  if key = \"right\"then    go to cd \"entry-3-n\"  end if  if key = \"up\"then    go to cd \"\"  end ifend arrowKeyNow we get the constraint string of this puzzle \"rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg\", these constraints, along with the path that goes to the lower right corner, are passed into one thing called XCMD which checks the path’s correctness natively (it contains binary instructions that directly run over the 68k CPU). There are 2 XCMD binaries which can be extracted by this tool, which seem can only run under MacOS. So I’m using the extracted binary from this great post for now instead.What’s more, I found that I can set breakpoints in the script and debug the game, I could even watch the variables on the fly:As for the XCMD part, it’s basically just a few hours’ reverse engineering work. Since there are currently no reliable decompilers for the 68k architecture, I have to read the assembly. It wasn’t too hard, but I did spend several hours learning the basic concepts of 68k’s instruction set.After the reverse engineering work, the watnesssolver’s checking methods can be rewritten in Python as:def build_automaton(constraints: str):    trans = str.maketrans(' rgb', '0123')    return [int(c) for c in constraints.translate(trans)]def choose_empty(r, g, b):    if g == 0 and b == 0:        return 0    if b &lt; g:        return 2    else:        return 3def choose_red(r, g, b):    if r != 2 and r != 3:        return 0    if b == 0 or g == 0:        return 0    return 1def choose_green(r, g, b):    if r &lt;= 4:        if b &lt;= 4:            if r == 2 or r == 3:                return 1            else:                return 2        else:            return 3    else:        return 0def choose_blue(r, g, b):    if r &lt;= 4:        if g &lt;= 4:            if r == 2 or r == 3:                return 1            else:                return 3        else:            return 2    else:        return 0def is_red(constraints, x, y):    if not (x &gt;= 0 and x &lt; 7 and y &gt;= 0 and y &lt; 7):        return False    return constraints[x+y*7] == 1def get_neighbors(constraints, x, y, color):    sum = 0    for bias_y in range(-1, 2):        for bias_x in range(-1, 2):            if (bias_x != 0 or bias_y != 0) and (y + bias_y &gt;= 0 and y + bias_y &lt; 7) and \\                    (x + bias_x &gt;= 0 and x + bias_x &lt; 7) and constraints[(x+bias_x)+(y+bias_y)*7] == color:                sum += 1    return sumdef step_automaton(constraints):    new_constraints = constraints[:]    for y in range(7):        for x in range(7):            r, g, b = \\                get_neighbors(constraints, x, y, 1), \\                get_neighbors(constraints, x, y, 2), \\                get_neighbors(constraints, x, y, 3)            if constraints[x+y*7] == 0:                new_constraints[x+y*7] = choose_empty(r, g, b)            elif constraints[x+y*7] == 1:                new_constraints[x+y*7] = choose_red(r, g, b)            elif constraints[x+y*7] == 2:                new_constraints[x+y*7] = choose_green(r, g, b)            elif constraints[x+y*7] == 3:                new_constraints[x+y*7] = choose_blue(r, g, b)    return new_constraintsdef perform_move(constraints, mem, x, y, d):    bias_x, bias_y = 0, 0    if d == 'U':        bias_x, bias_y = 0, -1    elif d == 'D':        bias_x, bias_y = 0, 1    elif d == 'L':        bias_x, bias_y = -1, 0    elif d == 'R':        bias_x, bias_y = 1, 0    if not (x+bias_x &gt;= 0 and x+bias_x &lt; 8 and y+bias_y &gt;= 0 and y+bias_y &lt; 8):        return False, x, y    min_x = min(x, x+bias_x)    min_y = min(y, y+bias_y)    if bias_y == 0:        if not (is_red(constraints, min_x, y) or is_red(constraints, min_x, y-1)):            return False, x, y    else:        if not (is_red(constraints, x, min_y) or is_red(constraints, x-1, min_y)):            return False, x, y    if mem[x+bias_x][y+bias_y] == 1:        return False, x, y    mem[x+bias_x][y+bias_y] = 1    return True, x+bias_x, y+bias_ydef solver(path, constraints):    x = y = 0    constraints = build_automaton(constraints)    mem = [[0 for i in range(8)] for j in range(8)]  # been to or not    mem[0][0] = 1    for each in path:        yes, new_x, new_y = perform_move(constraints, mem, x, y, each)        if yes:            if new_x == 7 and new_y == 7:                # print(f'Path `{path}` is great ' + '!' * 20)                return True, True            x, y = new_x, new_y            constraints = step_automaton(constraints)        else:            #print(f'Path `{path}` is bad')            return False, False    return True, FalseLooking around in the game, we’ll know that there are 3 puzzles we need to solve. So we can simply run 3 DFS searches on these contraints and three unique solutions will be printed out.def dfs(depth, path, constraints):    if depth &gt; 24: # figured out after multiple tests        return    mov, end = solver(path, constraints)    if end == True:        print(f'Path {path} is ok')    if mov == False:        return    for d in 'LRUD':        n_path = path + d        dfs(depth+1, n_path, constraints)if __name__ == '__main__':    constraints_stage1 = 'rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg'    constraints_stage2 = 'rbr  bbggrgrggb   bggbb b  b bbrbbgg gbrrbgrbbb g'    constraints_stage3 = 'rrbrb rg g  bgrbgggr ggrgr gr rg brr  b  bggrbgbb'    print('Stage1 solution:')    dfs(0, '', constraints_stage1)    print('Stage2 solution:')    dfs(0, '', constraints_stage2)    print('Stage3 solution:')    dfs(0, '', constraints_stage3)Output:Stage1 solution:Path RDDDRURRRDLLDLDRRURRDDDR is okStage2 solution:Path RDDRURDDDRURULURRDDDDDRD is okStage3 solution:Path DRDDDDRUURRRULURRDDDDDDR is okInput these solutions to each puzzle, after that, we could go to the lock-like thing on the white gate to reveal the flag:",
            "content_html": "<h2 id=\"intro\">Intro</h2><p>Recently in PlaidCTF2020 there was a RE challenge called <em>The Watness 2</em>, which is a game that requires the application <em>HyperCard</em> to run. Since I did not have a Macbook computer, I’d been struggling figuring out ways to run this game over my Windows 10 laptop. Here is how I finally managed to do that.</p><h2 id=\"steps\">Steps</h2><ul>  <li>Follow <a href=\"https://www.youtube.com/watch?v=TY3pjSGg1y4\">this great video tutorial</a></li>  <li>Download <a href=\"https://www.macintoshrepository.org/2475-stuffit-expander-and-dropstuff-5-5\">StuffitExpander</a>, add it to the volumes’ list, install it inside the VM:</li></ul><p><img src=\"/assets/HypercardOverWindows/1587369699146.png\" alt=\"1587369699146\" /></p><ul>  <li>Download <a href=\"https://macintoshgarden.org/apps/hypercard-241\">HyperCard 2.4</a>, install it inside the VM as described above</li>  <li>Extract the .rc1 file from the .sit file and open it with a simple double-click:</li></ul><p><img src=\"/assets/HypercardOverWindows/1587369949569.png\" alt=\"1587369949569\" /></p><h3 id=\"challenge-solution\">Challenge Solution</h3><p>Extract the stack’s script code:</p><p><img src=\"/assets/HypercardOverWindows/1587389434804.png\" alt=\"1587389434804\" /></p><pre><code>on openCard  Send colorMe to this card  pass openCardend openCardon closeCard  global prev_card  get the id of this cd  put it into prev_card  lock screen  pass closeCardend closeCardon colorMe  AddColor colorCard,stamp,0end colorMeon openStack  AddColor install  setupMenu  go to card \"tun-1-n\"  pass openStackend openStackon closeStack  AddColor remove  pass closeStackend closeStackon genPuzzle  send \"doMenu New Button\" to Hypercardend genPuzzleon initCard  answer prev_cardend initCardon menuReset  setupMenu  pass menuResetend menuReseton setupMenu  if there is not a menu \"Watness\" then    create menu \"Watness\"    put \"Generate Puzzle\"&amp;return&amp;\"Init Card\"&amp;return&amp;\"Set up Nav\"&amp;return&amp;\"Create Puzzle\" into menu \"Watness\" with menuMsg genPuzzle,initCard,setupNav,constructPuzzle  end ifend setupMenuon setupNav  ask \"What is the name of this card\"  set name of this cd to it    ask \"Where should the left go?\"  put it into left_loc  send \"doMenu New Button\" to Hypercard  set height of the last button to 342  set width of the last button to 100  set topleft of the last button to \"0,0\"  set style of the last button to \"transparent\"  set name of the last button to \"\"  put \"on mouseUp\"&amp;return&amp;\"go to card \"&amp;quote&amp;\"\"&amp;left_loc&amp;quote&amp;return&amp;\"end mouseUp\" into left_script  set script of last button to left_script    ask \"Where should the right go?\"  put it into right_loc  send \"doMenu New Button\" to Hypercard  set height of the last button to 342  set width of the last button to 100  set topleft of the last button to \"412,0\"  set style of the last button to \"transparent\"  set name of the last button to \"\"  put \"on mouseUp\"&amp;return&amp;\"go to card \"&amp;quote&amp;\"\"&amp;right_loc&amp;quote&amp;return&amp;\"end mouseUp\" into right_script  set script of last button to right_script    ask \"Where should fwd go?\"  put it into fwd_loc  send \"doMenu New Button\" to Hypercard  set height of the last button to 342  set width of the last button to 311  set the top of the last button to 0  set the left of the last button to 100  set style of the last button to \"transparent\"  set name of the last button to \"\"  put \"on mouseUp\"&amp;return&amp;\"go to card \"&amp;quote&amp;\"\"&amp;fwd_loc&amp;quote&amp;return&amp;\"end mouseUp\" into fwd_script  set script of last button to fwd_script    get the script of this card  put it into cd_script  put cd_script&amp;return into cd_script  put cd_script&amp;\"on arrowKey key\"&amp;return into cd_script  put cd_script&amp;\" if key = \"&amp;quote&amp;\"left\"&amp;quote&amp;\"then\"&amp;return into cd_script  put cd_script&amp;\"  go to cd \"&amp;quote&amp;left_loc&amp;quote&amp;return into cd_script  put cd_script&amp;\" end if\"&amp;return into cd_script  put cd_script&amp;\" if key = \"&amp;quote&amp;\"right\"&amp;quote&amp;\"then\"&amp;return into cd_script  put cd_script&amp;\"  go to cd \"&amp;quote&amp;right_loc&amp;quote&amp;return into cd_script  put cd_script&amp;\" end if\"&amp;return into cd_script  put cd_script&amp;\" if key = \"&amp;quote&amp;\"up\"&amp;quote&amp;\"then\"&amp;return into cd_script  put cd_script&amp;\"  go to cd \"&amp;quote&amp;fwd_loc&amp;quote&amp;return into cd_script  put cd_script&amp;\" end if\"&amp;return into cd_script  put cd_script&amp;\"end arrowKey\"&amp;return into cd_script      set the script of this cd to cd_scriptend setupNavon makeNode  global node  send \"doMenu New Button\" to Hypercard  put the id of the last button into nodeend makeNodeon constructPuzzle  global node,constraints    ask \"What are the constraints\"  put it into constraints    get the script of this cd  put it into cd_script  put cd_script&amp;return into cd_script  put cd_script&amp;\"on openCard\"&amp;return into cd_script  put cd_script&amp;\"  global constraints,path,cursor_x,cursor_y,\" into cd_script    put 0 into i  repeat for 8        put 0 into j    repeat for 8      put cd_script&amp;\"active_\"&amp;i&amp;\"_\"&amp;j&amp;\",\" into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put cd_script&amp;\"dummy\"&amp;return into cd_script  put cd_script&amp;\"  colorme\"&amp;return into cd_script  put cd_script&amp;\"  put -1 into cursor_x\"&amp;return into cd_script  put cd_script&amp;\"  put 0 into cursor_y\"&amp;return into cd_script  put cd_script&amp;\"  put \"&amp;quote&amp;quote&amp;\" into path\"&amp;return into cd_script  put cd_script&amp;\"  put \"&amp;quote&amp;constraints&amp;quote&amp;\" into constraints\"&amp;return into cd_script    put 1 into c_i  put 0 into i  repeat for 7        put 0 into j    repeat for 7      get char (j*7+i+1) of constraints      put it into letter            if letter &lt;&gt; \" \" then        makeNode                set the width of button id node to 10        set the height of button id node to 10                set the top of button id node to (76 + j * 30)        set the left of button id node to (161 + i * 30)                set the style of button id node to \"opaque\"        set showName of button id node to false                if letter = \"r\" then          put \"65535,0,0\" into node_color        end if        if letter = \"g\" then          put \"0,65535,0\" into node_color        end if        if letter = \"b\" then          put \"0,0,65535\" into node_color        end if                if letter &lt;&gt; \" \" then          addColor colorButton, cd, node, node_color                    put cd_script&amp;\"  addColor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;node_color&amp;quote&amp;return into cd_script        end if      end if                        put j+1 into j    end repeat        put i+1 into i  end repeat        put 0 into i  repeat for 8        put 0 into j    repeat for 8      put cd_script&amp;\"  put \"&amp;quote&amp;quote&amp;\" into active_\"&amp;i&amp;\"_\"&amp;j&amp;return into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    makeNode    set the width of button id node to 10  set the height of button id node to 15  set the left of button id node to 356  set the top of button id node to 276  set the name of button id node to \"path_extension\"  set showName of button id node to false  set the style of button id node to opaque  addcolor colorButton, cd, node, \"37632,30208,12288\"    put \"\" into node_script  put node_script&amp;\"on checkYoSelf\"&amp;return into node_script  put node_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script  put node_script&amp;\"end checkYoSelf\"&amp;return into node_script    set the script of button id node to node_script    put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script      makeNode    set the width of button id node to 10  set the height of button id node to 10  set the left of button id node to 356  set the top of button id node to 286  set the name of button id node to \"finale\"  set showName of button id node to false  set the style of button id node to oval  addcolor colorButton, cd, node, \"37632,30208,12288\"    put \"\" into node_script  put node_script&amp;\"on mouseUp\"&amp;return into node_script  put node_script&amp;\"  global cursor_x, cursor_y\"&amp;return into node_script  put node_script&amp;\"  if (cursor_x = 7) and (cursor_y = 7) then\"&amp;return into node_script  put node_script&amp;\"    addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script  put node_script&amp;\"    send \"&amp;quote&amp;\"checkYoSelf\"&amp;quote&amp;\" to button path_extension\"&amp;return into node_script  put node_script&amp;\"    send \"&amp;quote&amp;\"checkSolution\"&amp;quote&amp;\" to this cd\"&amp;return into node_script  put node_script&amp;\"  end if\"&amp;return into node_script  put node_script&amp;\"end mouseUp\"&amp;return into node_script    set the script of button id node to node_script    put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script    put 0 into i  repeat for 7        put 0 into j    repeat for 8      makeNode            set the width of button id node to 30      set the height of button id node to 10            set the top of button id node to (61 + 30 * j)      set the left of button id node to (151 + 30 * i)            set the style of button id node to opaque      set the name of button id node to \"h_path_\"&amp;i&amp;\"_\"&amp;j            set showName of button id node to false            addcolor colorButton, cd, node, \"37632,30208,12288\"            put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script            get the script of button id node      put it into node_script            put \"active_\"&amp;i&amp;\"_\"&amp;j into f_node      put \"active_\"&amp;(i+1)&amp;\"_\"&amp;j into s_node            put node_script&amp;return into node_script      put node_script&amp;\"on checkYoSelf\"&amp;return into node_script      put node_script&amp;\"  global \"&amp;f_node&amp;\",\"&amp;s_node&amp;return into node_script      put node_script&amp;\"  if (\"&amp;f_node&amp;\" = true) and (\"&amp;s_node&amp;\" = true) then\"&amp;return into node_script      put node_script&amp;\"    addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script      put node_script&amp;\"  end if\"&amp;return into node_script      put node_script&amp;\"end checkYoSelf\"&amp;return into node_script            set the script of button id node to node_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put 0 into i  repeat for 8        put 0 into j    repeat for 7      makeNode            set the width of button id node to 10      set the height of button id node to 30            set the top of button id node to (66 + 30 * j)      set the left of button id node to (146 + 30 * i)            set the style of button id node to opaque      set the name of button id node to \"v_path_\"&amp;i&amp;\"_\"&amp;j            set showName of button id node to false            addcolor colorButton, cd, node, \"37632,30208,12288\"            put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script            get the script of button id node      put it into node_script            put \"active_\"&amp;i&amp;\"_\"&amp;j into f_node      put \"active_\"&amp;i&amp;\"_\"&amp;(j+1) into s_node            put node_script&amp;return into node_script      put node_script&amp;\"on checkYoSelf\"&amp;return into node_script      put node_script&amp;\"  global \"&amp;f_node&amp;\",\"&amp;s_node&amp;return into node_script      put node_script&amp;\"  if (\"&amp;f_node&amp;\" = true) and (\"&amp;s_node&amp;\" = true) then\"&amp;return into node_script      put node_script&amp;\"    addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script      put node_script&amp;\"  end if\"&amp;return into node_script      put node_script&amp;\"end checkYoSelf\"&amp;return into node_script            set the script of button id node to node_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put 0 into i  repeat for 8        put 0 into j    repeat for 8      makeNode            set the width of button id node to 10      set the height of button id node to 10            set the top of button id node to (61 + 30 * j)      set the left of button id node to (146 + 30 * i)            set the style of button id node to oval      set the name of button id node to \"button_\"&amp;i&amp;\"_\"&amp;j            set showName of button id node to false            addcolor colorButton, cd, node, \"37632,30208,12288\"            put \"active_\"&amp;i&amp;\"_\"&amp;j into v_name            put \"\" into node_script      put node_script&amp;\"on mouseUp\"&amp;return into node_script      put node_script&amp;\"  global \"&amp;v_name&amp;\",cursor_x,cursor_y\"&amp;return into node_script      put node_script&amp;\"  put cursor_x into prev_x\"&amp;return into node_script      put node_script&amp;\"  put cursor_y into prev_y\"&amp;return into node_script      put node_script&amp;\"  put abs(cursor_x-\"&amp;i&amp;\") into dx\"&amp;return into node_script      put node_script&amp;\"  put abs(cursor_y-\"&amp;j&amp;\") into dy\"&amp;return into node_script      put node_script&amp;\"  if (\"&amp;v_name&amp;\" = \"&amp;quote&amp;quote&amp;\") and ((dx = 1 and dy = 0) or (dx = 0 and dy = 1)) then\"&amp;return into node_script      put node_script&amp;\"    put true into \"&amp;v_name&amp;return into node_script      put node_script&amp;\"    send \"&amp;quote&amp;\"updateState \"&amp;i&amp;\",\"&amp;j&amp;quote&amp;\" to this cd\"&amp;return into node_script      put node_script&amp;\"    addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"65535,65535,30000\"&amp;quote&amp;return into node_script      put node_script&amp;\"  end if\"&amp;return into node_script      put node_script&amp;\"end mouseUp\"&amp;return into node_script            set the script of button id node to node_script            put cd_script&amp;\"  addcolor colorButton, cd, \"&amp;node&amp;\", \"&amp;quote&amp;\"37632,30208,12288\"&amp;quote&amp;return into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    set the width of button button_0_0 to 30  set the height of button button_0_0 to 30    set the top of button button_0_0 to 51  set the left of button button_0_0 to 136    get the id of button button_0_0  addColor colorButton, cd, it, \"37632,30208,12288\"    put cd_script&amp;\"end openCard\"&amp;return into cd_script  set the script of this cd to cd_script  end constructPuzzleon checkSolution  global puzzle_id,path,constraints,flag_1,flag_2,flag_3  watnesssolver constraints,path  put the result into success  if success = \"true\" then    if puzzle_id = 1 then      decoder path,\"clrtffxpry\"      put the result into flag_1    end if    if puzzle_id = 2 then      decoder path,\"nyghq7xksg\"      put the result into flag_2    end if    if puzzle_id = 3 then      decoder path,\"ppyyvn}1{7\"      put the result into flag_3    end if  else    send opencard to this cd  end ifend checkSolutionon updateState i,j  global path,cursor_x,cursor_y    if (i &lt;&gt; 0) or (j &lt;&gt; 0) then    if (cursor_y = j+1) and (cursor_x = i) then      put path&amp;\"U\" into path    end if    if (cursor_y = j) and (cursor_x = i - 1) then      put path&amp;\"R\" into path    end if    if (cursor_y = j-1) and (cursor_x = i) then      put path&amp;\"D\" into path    end if    if (cursor_y = j) and (cursor_x = i + 1) then      put path&amp;\"L\" into path    end if  end if      if cursor_x &gt;= 0 and cursor_y &gt;= 0 then    put \"h_path_\"&amp;min(cursor_x, i)&amp;\"_\"&amp;min(cursor_y, j) into h_path    put \"v_path_\"&amp;min(cursor_x, i)&amp;\"_\"&amp;min(cursor_y, j) into v_path        if i = cursor_x then      send checkYoSelf to button v_path    end if        if j = cursor_y then      send checkYoSelf to button h_path    end if      end if    put i into cursor_x  put j into cursor_yend updateState</code></pre><p>The card’s script code can also be extracted (puzzle 1):</p><pre><code>on openCard  global puzzle_id,constraints,path,cursor_x,cursor_y,active_0_0,active_0_1,active_0_2,active_0_3,active_0_4,active_0_5,active_0_6,active_0_7,active_1_0,active_1_1,active_1_2,active_1_3,active_1_4,active_1_5,active_1_6,active_1_7,active_2_0,active_2_1,active_2_2,active_2_3,active_2_4,active_2_5,active_2_6,active_2_7,active_3_0,active_3_1,active_3_2,active_3_3,active_3_4,active_3_5,active_3_6,active_3_7,active_4_0,active_4_1,active_4_2,active_4_3,active_4_4,active_4_5,active_4_6,active_4_7,active_5_0,active_5_1,active_5_2,active_5_3,active_5_4,active_5_5,active_5_6,active_5_7,active_6_0,active_6_1,active_6_2,active_6_3,active_6_4,active_6_5,active_6_6,active_6_7,active_7_0,active_7_1,active_7_2,active_7_3,active_7_4,active_7_5,active_7_6,active_7_7,dummy  colorme  put 1 into puzzle_id  put -1 into cursor_x  put 0 into cursor_y  put \"\" into path  put \"rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg\" into constraints  addColor colorButton, cd, 1, \"65535,0,0\"  ...end openCardon arrowKey key  if key = \"left\"then    go to cd \"entry-3-n\"  end if  if key = \"right\"then    go to cd \"entry-3-n\"  end if  if key = \"up\"then    go to cd \"\"  end ifend arrowKey</code></pre><p>Now we get the constraint string of this puzzle <code>\"rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg\"</code>, these constraints, along with the path that goes to the lower right corner, are passed into one thing called <em>XCMD</em> which checks the path’s correctness natively (it contains binary instructions that directly run over the 68k CPU). There are 2 XCMD binaries which can be extracted by <a href=\"https://github.com/PierreLorenzi/HyperCardPreview\">this tool</a>, which seem can only run under MacOS. So I’m using the extracted binary from <a href=\"https://ctf.harrisongreen.me/2020/plaidctf/the_watness_2/\">this</a> great post for now instead.</p><p>What’s more, I found that I can set breakpoints in the script and debug the game, I could even watch the variables on the fly:</p><p><img src=\"/assets/HypercardOverWindows/1588514193878.png\" alt=\"1588514193878\" /></p><p>As for the XCMD part, it’s basically just a few hours’ reverse engineering work. Since there are currently no reliable decompilers for the 68k architecture, I have to read the assembly. It wasn’t too hard, but I did spend several hours learning the basic concepts of 68k’s instruction set.</p><p>After the reverse engineering work, the watnesssolver’s checking methods can be rewritten in Python as:</p><pre><code class=\"language-python\">def build_automaton(constraints: str):    trans = str.maketrans(' rgb', '0123')    return [int(c) for c in constraints.translate(trans)]def choose_empty(r, g, b):    if g == 0 and b == 0:        return 0    if b &lt; g:        return 2    else:        return 3def choose_red(r, g, b):    if r != 2 and r != 3:        return 0    if b == 0 or g == 0:        return 0    return 1def choose_green(r, g, b):    if r &lt;= 4:        if b &lt;= 4:            if r == 2 or r == 3:                return 1            else:                return 2        else:            return 3    else:        return 0def choose_blue(r, g, b):    if r &lt;= 4:        if g &lt;= 4:            if r == 2 or r == 3:                return 1            else:                return 3        else:            return 2    else:        return 0def is_red(constraints, x, y):    if not (x &gt;= 0 and x &lt; 7 and y &gt;= 0 and y &lt; 7):        return False    return constraints[x+y*7] == 1def get_neighbors(constraints, x, y, color):    sum = 0    for bias_y in range(-1, 2):        for bias_x in range(-1, 2):            if (bias_x != 0 or bias_y != 0) and (y + bias_y &gt;= 0 and y + bias_y &lt; 7) and \\                    (x + bias_x &gt;= 0 and x + bias_x &lt; 7) and constraints[(x+bias_x)+(y+bias_y)*7] == color:                sum += 1    return sumdef step_automaton(constraints):    new_constraints = constraints[:]    for y in range(7):        for x in range(7):            r, g, b = \\                get_neighbors(constraints, x, y, 1), \\                get_neighbors(constraints, x, y, 2), \\                get_neighbors(constraints, x, y, 3)            if constraints[x+y*7] == 0:                new_constraints[x+y*7] = choose_empty(r, g, b)            elif constraints[x+y*7] == 1:                new_constraints[x+y*7] = choose_red(r, g, b)            elif constraints[x+y*7] == 2:                new_constraints[x+y*7] = choose_green(r, g, b)            elif constraints[x+y*7] == 3:                new_constraints[x+y*7] = choose_blue(r, g, b)    return new_constraintsdef perform_move(constraints, mem, x, y, d):    bias_x, bias_y = 0, 0    if d == 'U':        bias_x, bias_y = 0, -1    elif d == 'D':        bias_x, bias_y = 0, 1    elif d == 'L':        bias_x, bias_y = -1, 0    elif d == 'R':        bias_x, bias_y = 1, 0    if not (x+bias_x &gt;= 0 and x+bias_x &lt; 8 and y+bias_y &gt;= 0 and y+bias_y &lt; 8):        return False, x, y    min_x = min(x, x+bias_x)    min_y = min(y, y+bias_y)    if bias_y == 0:        if not (is_red(constraints, min_x, y) or is_red(constraints, min_x, y-1)):            return False, x, y    else:        if not (is_red(constraints, x, min_y) or is_red(constraints, x-1, min_y)):            return False, x, y    if mem[x+bias_x][y+bias_y] == 1:        return False, x, y    mem[x+bias_x][y+bias_y] = 1    return True, x+bias_x, y+bias_ydef solver(path, constraints):    x = y = 0    constraints = build_automaton(constraints)    mem = [[0 for i in range(8)] for j in range(8)]  # been to or not    mem[0][0] = 1    for each in path:        yes, new_x, new_y = perform_move(constraints, mem, x, y, each)        if yes:            if new_x == 7 and new_y == 7:                # print(f'Path `{path}` is great ' + '!' * 20)                return True, True            x, y = new_x, new_y            constraints = step_automaton(constraints)        else:            #print(f'Path `{path}` is bad')            return False, False    return True, False</code></pre><p>Looking around in the game, we’ll know that there are 3 puzzles we need to solve. So we can simply run 3 DFS searches on these contraints and three unique solutions will be printed out.</p><pre><code class=\"language-python\">def dfs(depth, path, constraints):    if depth &gt; 24: # figured out after multiple tests        return    mov, end = solver(path, constraints)    if end == True:        print(f'Path {path} is ok')    if mov == False:        return    for d in 'LRUD':        n_path = path + d        dfs(depth+1, n_path, constraints)if __name__ == '__main__':    constraints_stage1 = 'rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg'    constraints_stage2 = 'rbr  bbggrgrggb   bggbb b  b bbrbbgg gbrrbgrbbb g'    constraints_stage3 = 'rrbrb rg g  bgrbgggr ggrgr gr rg brr  b  bggrbgbb'    print('Stage1 solution:')    dfs(0, '', constraints_stage1)    print('Stage2 solution:')    dfs(0, '', constraints_stage2)    print('Stage3 solution:')    dfs(0, '', constraints_stage3)</code></pre><p>Output:</p><pre><code>Stage1 solution:Path RDDDRURRRDLLDLDRRURRDDDR is okStage2 solution:Path RDDRURDDDRURULURRDDDDDRD is okStage3 solution:Path DRDDDDRUURRRULURRDDDDDDR is ok</code></pre><p>Input these solutions to each puzzle, after that, we could go to the lock-like thing on the white gate to reveal the flag:</p><p><img src=\"/assets/HypercardOverWindows/1588514105474.png\" alt=\"1588514105474\" /></p>",
            "url": "http://localhost:4000/2020/04/20/hypercard-over-windows",
            
            
            
            "tags": ["Write-up","Reverse Engineering","Hypercard","CTF","PlaidCTF2020"],
            
            "date_published": "2020-04-20T00:00:00+08:00",
            "date_modified": "2020-04-20T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/03/12/write-invalid-and-cache-coherence",
            "title": "Write Invalid and Cache Coherence",
            "summary": null,
            "content_text": "// This post was written in ChineseIntro今天分布式听飘了，个人感觉老师放的课件对问题的描述以及解答有些欠缺，后来做了些资料检索，对下面这个简单问题做了些总结：对于 write-update、write-invalidate 两种 coherence protocol，哪一种在生产消费者模型下的性能更差？首先得知道 coherence protocol 的目的是什么，它的目的很简单：保证多处理器系统下的数据一致性。有两类这种协议，一种是 snoopy-based 另一种是 directory-based（当然还有一个 shared caches 概念这里也不讨论了），对于前者来说，所有读写、更新操作都以类似广播的方式发给所有处理器，每个处理器相应地 snoop and respond，write-update 和 write-invalid 都是属于这一类，这两种方式的定义分别如下：  Write-update: When a write operation is observed to a location that a cache has a copy of, the cache controller updates its own copy of the snooped memory location with the new data.  Write-invalidate: When a write operation is observed to a location that a cache has a copy of, the cache controller invalidates its own copy of the snooped memory location, which forces a read from main memory of the new value on its next access.Write-invalidate 在一些情况下的优势是很明显的，例如突发大量对单个单元写请求的情况下，它比 write-update 有更好的效果，其每次对内存单元的更新不会引起其他 cache 的更新，因为这个时候其他单元不一定总有 read 请求，write 之后只会对这个内存对应的 cache（其 copy）做一个 invalid 标记，并且在做标记之前如果发现已经是 invalid 状态就不用更新了，因此在没有 read 的情况下只需要发送一次 invalidation 广播，下次其他单元需要访问相应内存时检测到自己 cache 上的 invalid 标记就直接去主存里取数据并更新自己的 cache。此外还有一种情况，例如 writes to different words of a block，write-update 在每一个 word 写操作都会发送一次更新请求，而 write-invalidate 由于同理也只会发送一次 invalidation 广播。但是对于 producer-consumer 模型而言，producer 的每次更新都要等待一个 consumer 来消费，这就是与之前两种情况不同的一点。这种情况下如果每次还是采用广播 invalidate 消息的方法，下一次某个 consumer 消费的时候检测到自己 cache invalid 状态后便还需要去访问主存，这是完全多余的了，因为我们完全可以在生成好之后直接更新 consumer 的 cache，这样只需要一次写会主存的操作而不是两次。因此这时 write-update 优于 write-invalidate。总结一下，对于大量连续的写请求来说，write-invalidate 更好，对于 producer-consumer 这种供需平衡的模型来说 write-update 更优。关于 cache coherency 这方面还有许多复杂并且值得探讨的问题，但由于它们太过学术我没有去深究。References  https://www3.nd.edu/~mniemier/teaching/2010_B_Fall/lectures/lec_27_slides.pdf.  https://www.cs.utah.edu/~retrac/papers/hpca07.pdf.",
            "content_html": "<p>// This post was written in Chinese</p><h2 id=\"intro\">Intro</h2><p>今天分布式听飘了，个人感觉老师放的课件对问题的描述以及解答有些欠缺，后来做了些资料检索，对下面这个简单问题做了些总结：</p><p>对于 write-update、write-invalidate 两种 coherence protocol，哪一种在生产消费者模型下的性能更差？</p><hr /><p>首先得知道 coherence protocol 的目的是什么，它的目的很简单：保证多处理器系统下的数据一致性。</p><p>有两类这种协议，一种是 snoopy-based 另一种是 directory-based（当然还有一个 shared caches 概念这里也不讨论了），对于前者来说，所有读写、更新操作都以类似广播的方式发给所有处理器，每个处理器相应地 snoop and respond，write-update 和 write-invalid 都是属于这一类，这两种方式的定义分别如下：</p><ul>  <li>Write-update: When a write operation is observed to a location that a cache has a copy of, the cache controller updates its own copy of the snooped memory location with the new data.</li>  <li>Write-invalidate: When a write operation is observed to a location that a cache has a copy of, the cache controller invalidates its own copy of the snooped memory location, which forces a read from main memory of the new value on its next access.</li></ul><p>Write-invalidate 在一些情况下的优势是很明显的，例如突发大量对单个单元写请求的情况下，它比 write-update 有更好的效果，其每次对内存单元的更新不会引起其他 cache 的更新，因为这个时候其他单元不一定总有 read 请求，write 之后只会对这个内存对应的 cache（其 copy）做一个 invalid 标记，并且在做标记之前如果发现已经是 invalid 状态就不用更新了，因此在没有 read 的情况下只需要发送一次 invalidation 广播，下次其他单元需要访问相应内存时检测到自己 cache 上的 invalid 标记就直接去主存里取数据并更新自己的 cache。</p><p>此外还有一种情况，例如 writes to different words of a block，write-update 在每一个 word 写操作都会发送一次更新请求，而 write-invalidate 由于同理也只会发送一次 invalidation 广播。</p><p>但是对于 producer-consumer 模型而言，producer 的每次更新都要等待一个 consumer 来消费，这就是与之前两种情况不同的一点。这种情况下如果每次还是采用广播 invalidate 消息的方法，下一次某个 consumer 消费的时候检测到自己 cache invalid 状态后便还需要去访问主存，这是完全多余的了，因为我们完全可以在生成好之后直接更新 consumer 的 cache，这样只需要一次写会主存的操作而不是两次。因此这时 write-update 优于 write-invalidate。</p><p>总结一下，对于大量连续的写请求来说，write-invalidate 更好，对于 producer-consumer 这种供需平衡的模型来说 write-update 更优。</p><hr /><p>关于 cache coherency 这方面还有许多复杂并且值得探讨的问题，但由于它们太过学术我没有去深究。</p><p><strong>References</strong></p><ul>  <li>https://www3.nd.edu/~mniemier/teaching/2010_B_Fall/lectures/lec_27_slides.pdf.</li>  <li>https://www.cs.utah.edu/~retrac/papers/hpca07.pdf.</li></ul>",
            "url": "http://localhost:4000/2020/03/12/write-invalid-and-cache-coherence",
            
            
            
            "tags": ["distributed computing","cache coherence","write-invalid","class notes"],
            
            "date_published": "2020-03-12T00:00:00+08:00",
            "date_modified": "2020-03-12T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        },
    
        {
            "id": "http://localhost:4000/2020/02/20/ancient-game-v2",
            "title": "D^3CTF2019 Ancient Game V2, thoughts & solutions",
            "summary": null,
            "content_text": "IntroI designed the RE challenge Ancient Game V2 in D^3CTF2019. This post is about some related stuff along with the chal’s solution.ChallengeThis challenge uses a virtual architecture similar to OISC to implement a classic Sudoku verification. There are 4 types of instructions, and all logical operations are implemented through NAND gates. A branch control and two I / O interrupts are also issued.Operations like XOR / AND / OR are all implemented by combinations of NAND gates, for example:xor x,y =&gt;xor_tmp[0] = y NAND yxor_tmp[1] = x NAND xor_tmp[0]xor_tmp[2] = x NAND xxor_tmp[3] = y NAND xor_tmp[2]x = xor_tmp[1] NAND xor_tmp[3]Which is based on the fact that:Q = A XOR B = [ B NAND ( A NAND A ) ] NAND [ A NAND ( B NAND B ) ]An excerpt of the Sudoku Verifier code in my self-defined assembly:welcome = mkstr(\"**************************\\n**  Welcome To D^3CTF   **\\n**   Ancient Game V2    **\\n**************************\\n\\nInput Flag:\")wrong = mkstr(\"\\nSorry, please try again.\\n\")correct = mkstr(\"\\nCorrect.\\n\")flag = new(50)// distract = new(1000)grid = new(81)// initialize the puzzleset(grid[0],9)set(grid[5],8)set(grid[9],1)set(grid[10],3)set(grid[14],9)set(grid[16],7)...set(grid[71],6)set(grid[75],9)set(grid[80],1)__code_start__// print the welcome messageprint(welcome)// get inputinput(flag[0])input(flag[1])input(flag[2])input(flag[3])input(flag[4])input(flag[5])...input(flag[46])input(flag[47])input(flag[48])input(flag[49])// transfer chars in the flag into the gridslong_transfer(flag[0],grid[1])long_transfer(flag[1],grid[2])...long_transfer(flag[47],grid[77])long_transfer(flag[48],grid[78])long_transfer(flag[49],grid[79])// xor with xor_table, which is introduced //   for generating different flags to different teamsgrid[1] = grid[1] ^ xor_table[0]grid[2] = grid[2] ^ xor_table[1]grid[3] = grid[3] ^ xor_table[2]grid[4] = grid[4] ^ xor_table[3]grid[6] = grid[6] ^ xor_table[4]grid[7] = grid[7] ^ xor_table[5]...grid[77] = grid[77] ^ xor_table[47]grid[78] = grid[78] ^ xor_table[48]grid[79] = grid[79] ^ xor_table[49]// verify the sudoku game// rowsjmp _label_wrong if grid[4] == grid[5]jmp _label_wrong if grid[4] == grid[6]jmp _label_wrong if grid[4] == grid[7]...jmp _label_wrong if grid[3] == grid[7]jmp _label_wrong if grid[3] == grid[8]// columnsjmp _label_wrong if grid[0] == grid[9]jmp _label_wrong if grid[0] == grid[18]jmp _label_wrong if grid[0] == grid[27]...jmp _label_wrong if grid[62] == grid[80]jmp _label_wrong if grid[71] == grid[80]// subgridsjmp _label_wrong if grid[0] == grid[1]jmp _label_wrong if grid[0] == grid[2]jmp _label_wrong if grid[0] == grid[9]jmp _label_wrong if grid[0] == grid[10]...jmp _label_wrong if grid[78] == grid[79]jmp _label_wrong if grid[78] == grid[80]jmp _label_wrong if grid[79] == grid[80]// check rangejmp _label_wrong if outofnumbers(grid[1])jmp _label_wrong if outofnumbers(grid[2])jmp _label_wrong if outofnumbers(grid[3])jmp _label_wrong if outofnumbers(grid[4])...jmp _label_wrong if outofnumbers(grid[76])jmp _label_wrong if outofnumbers(grid[77])jmp _label_wrong if outofnumbers(grid[78])jmp _label_wrong if outofnumbers(grid[79])_label_correct:print(correct)return_label_wrong:print(wrong)returnI wrote an assembler for this assembly, which was used to generate the final challenge that the players got. The assembler wasn’t open-sourced since it’s ugly.During the competition, due to the negligence of myself, the implementation of the outofnumbers (var) function was incorrectly written as return var in range (10), resulting in multiple solutions. Since the target Sudoku should only be filled with 1 ~ 9, the correct implementation should be return var in range (1, 10). This was my fault, and I had to update the challenge with a fixed one during the competition.Sudoku MapSolutionTo solve this challenge, there is no need to simplify all the logical operations. Since there is no complicated loop in the chal’s actual control flow, we can find conditions that prevent the control flow from jumping to the part which outputs “Sorry” through simple control flow tracing and symbolic analysis. Finally, we can use an SMT solver to solve the constraints that we get through the previous analysis(That’s how ThinerDAS solved this challenge).Flag: d3ctf{g5lk9t28zz47y3l6m2kosbajd2vk9e2dwghxgfktcki}  Referenceable solution script: sol.py by ByaiduThe source code of this challenge(not fully open-sourced) and a duplicate of this post are uploaded to GitHub, check them out at: https://github.com/yype/D3CTF_Rev/tree/master/AncientGameV2.More..I’ve always found OISC quite interesting to me. This challenge was just a demo of one of my ideas, maybe I will do some extra work related to OISC in the upcoming future.",
            "content_html": "<h2 id=\"intro\">Intro</h2><p>I designed the RE challenge <em>Ancient Game V2</em> in D^3CTF2019. This post is about some related stuff along with the chal’s solution.</p><h2 id=\"challenge\">Challenge</h2><p>This challenge uses a virtual architecture similar to OISC to implement a classic Sudoku verification. There are 4 types of instructions, and all logical operations are implemented through NAND gates. A branch control and two I / O interrupts are also issued.</p><p>Operations like XOR / AND / OR are all implemented by combinations of NAND gates, for example:</p><pre><code>xor x,y =&gt;xor_tmp[0] = y NAND yxor_tmp[1] = x NAND xor_tmp[0]xor_tmp[2] = x NAND xxor_tmp[3] = y NAND xor_tmp[2]x = xor_tmp[1] NAND xor_tmp[3]</code></pre><p>Which is based on the fact that:</p><pre><code>Q = A XOR B = [ B NAND ( A NAND A ) ] NAND [ A NAND ( B NAND B ) ]</code></pre><p>An excerpt of the Sudoku Verifier code in my <em>self-defined assembly</em>:</p><pre><code>welcome = mkstr(\"**************************\\n**  Welcome To D^3CTF   **\\n**   Ancient Game V2    **\\n**************************\\n\\nInput Flag:\")wrong = mkstr(\"\\nSorry, please try again.\\n\")correct = mkstr(\"\\nCorrect.\\n\")flag = new(50)// distract = new(1000)grid = new(81)// initialize the puzzleset(grid[0],9)set(grid[5],8)set(grid[9],1)set(grid[10],3)set(grid[14],9)set(grid[16],7)...set(grid[71],6)set(grid[75],9)set(grid[80],1)__code_start__// print the welcome messageprint(welcome)// get inputinput(flag[0])input(flag[1])input(flag[2])input(flag[3])input(flag[4])input(flag[5])...input(flag[46])input(flag[47])input(flag[48])input(flag[49])// transfer chars in the flag into the gridslong_transfer(flag[0],grid[1])long_transfer(flag[1],grid[2])...long_transfer(flag[47],grid[77])long_transfer(flag[48],grid[78])long_transfer(flag[49],grid[79])// xor with xor_table, which is introduced //   for generating different flags to different teamsgrid[1] = grid[1] ^ xor_table[0]grid[2] = grid[2] ^ xor_table[1]grid[3] = grid[3] ^ xor_table[2]grid[4] = grid[4] ^ xor_table[3]grid[6] = grid[6] ^ xor_table[4]grid[7] = grid[7] ^ xor_table[5]...grid[77] = grid[77] ^ xor_table[47]grid[78] = grid[78] ^ xor_table[48]grid[79] = grid[79] ^ xor_table[49]// verify the sudoku game// rowsjmp _label_wrong if grid[4] == grid[5]jmp _label_wrong if grid[4] == grid[6]jmp _label_wrong if grid[4] == grid[7]...jmp _label_wrong if grid[3] == grid[7]jmp _label_wrong if grid[3] == grid[8]// columnsjmp _label_wrong if grid[0] == grid[9]jmp _label_wrong if grid[0] == grid[18]jmp _label_wrong if grid[0] == grid[27]...jmp _label_wrong if grid[62] == grid[80]jmp _label_wrong if grid[71] == grid[80]// subgridsjmp _label_wrong if grid[0] == grid[1]jmp _label_wrong if grid[0] == grid[2]jmp _label_wrong if grid[0] == grid[9]jmp _label_wrong if grid[0] == grid[10]...jmp _label_wrong if grid[78] == grid[79]jmp _label_wrong if grid[78] == grid[80]jmp _label_wrong if grid[79] == grid[80]// check rangejmp _label_wrong if outofnumbers(grid[1])jmp _label_wrong if outofnumbers(grid[2])jmp _label_wrong if outofnumbers(grid[3])jmp _label_wrong if outofnumbers(grid[4])...jmp _label_wrong if outofnumbers(grid[76])jmp _label_wrong if outofnumbers(grid[77])jmp _label_wrong if outofnumbers(grid[78])jmp _label_wrong if outofnumbers(grid[79])_label_correct:print(correct)return_label_wrong:print(wrong)return</code></pre><p>I wrote an assembler for this assembly, which was used to generate the final challenge that the players got. The assembler wasn’t open-sourced since it’s ugly.</p><p>During the competition, due to the negligence of myself, the implementation of the <code>outofnumbers (var)</code> function was incorrectly written as <code>return var in range (10)</code>, resulting in multiple solutions. Since the target Sudoku should only be filled with 1 ~ 9, the correct implementation should be <code>return var in range (1, 10)</code>. This was my fault, and I had to update the challenge with a fixed one during the competition.</p><p><strong>Sudoku Map</strong></p><p><img src=\"https://camo.githubusercontent.com/9e3d18179573b913f906045e17194334fe646330e821fc86032756fece3958a2/68747470733a2f2f692e696d6775722e636f6d2f50727a6d7945752e706e67\" alt=\"\" /></p><p><strong>Solution</strong></p><p>To solve this challenge, there is no need to simplify all the logical operations. Since there is no complicated loop in the chal’s actual control flow, we can find conditions that prevent the control flow from jumping to the part which outputs “Sorry” through simple control flow tracing and symbolic analysis. Finally, we can use an SMT solver to solve the constraints that we get through the previous analysis(That’s how ThinerDAS solved this challenge).</p><p>Flag: d3ctf{g5lk9t28zz47y3l6m2kosbajd2vk9e2dwghxgfktcki}</p><blockquote>  <p>Referenceable solution script: <a href=\"https://github.com/0h2o/D3CTF_Rev/blob/master/AncientGameV2/sol.py\">sol.py</a> by <a href=\"https://github.com/byaidu\">Byaidu</a></p></blockquote><p>The source code of this challenge(not fully open-sourced) and a duplicate of this post are uploaded to GitHub, check them out at: <a href=\"https://github.com/yype/D3CTF_Rev/tree/master/AncientGameV2\" target=\"_blank\">https://github.com/yype/D3CTF_Rev/tree/master/AncientGameV2</a>.</p><h2 id=\"more\">More..</h2><p>I’ve always found OISC quite interesting to me. This challenge was just a demo of one of my ideas, maybe I will do some extra work related to OISC in the upcoming future.</p>",
            "url": "http://localhost:4000/2020/02/20/ancient-game-v2",
            
            
            
            "tags": ["CTF","Reverse Engineering","D^3CTF2019","OISC"],
            
            "date_published": "2020-02-20T00:00:00+08:00",
            "date_modified": "2020-02-20T00:00:00+08:00",
            
                "author": 
                "{"twitter"=>nil, "name"=>nil, "avatar"=>nil, "email"=>nil, "url"=>nil}"
                
            
        }
    
    ]
}