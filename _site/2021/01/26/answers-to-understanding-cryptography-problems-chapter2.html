<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Solutions to Understanding Cryptography Problems - Chapter 2" /><meta property="og:locale" content="en_US" /><meta name="description" content="hacking &amp; exploring" /><meta property="og:description" content="hacking &amp; exploring" /><link rel="canonical" href="http://localhost:4000/2021/01/26/answers-to-understanding-cryptography-problems-chapter2" /><meta property="og:url" content="http://localhost:4000/2021/01/26/answers-to-understanding-cryptography-problems-chapter2" /><meta property="og:site_name" content="yype.site" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-01-26T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Solutions to Understanding Cryptography Problems - Chapter 2" /><meta name="twitter:site" content="@_yype" /> <script type="application/ld+json"> {"headline":"Solutions to Understanding Cryptography Problems - Chapter 2","dateModified":"2021-01-26T00:00:00+08:00","datePublished":"2021-01-26T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2021/01/26/answers-to-understanding-cryptography-problems-chapter2"},"description":"hacking &amp; exploring","url":"http://localhost:4000/2021/01/26/answers-to-understanding-cryptography-problems-chapter2","@type":"BlogPosting","@context":"https://schema.org"}</script><title> Solutions to Understanding Cryptography Problems - Chapter 2 - yype.site</title><link rel="shortcut icon" href="/favicon.png"><link rel="alternate" type="application/atom+xml" title="yype.site" href="/atom.xml"><link rel="alternate" type="application/json" title="yype.site" href="http://localhost:4000/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline;word-break:break-word}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0;word-break:break-word;display:inline}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:90%}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0;opacity:0.2}>ol,>ul,>dl{padding-left:2rem}>ol li+li,>ul li+li,>dl li+li{margin-top:0.3rem}li{word-break:break-word}li>ol,li>ul,li>dl{padding-left:2rem}li>p{margin:1rem 0 0.8rem}li>a{word-break:normal}ul>li{word-break:break-all}ul,ol{list-style-position:inside}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{margin:0.5rem 0;border-left:5px solid #ececec;padding-left:1rem;color:#363636}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">yype.site</h1>--><nav role="navigation"><ul><li><a href="/" >yype.site</a></li><li><a href="/about" >About</a></li><li><a href="/search" >Search</a></li><li><a href="/atom.xml" >Rss</a></li></ul></nav></header><section class="post"><h2>Solutions to Understanding Cryptography Problems - Chapter 2</h2><link href="/assets/css/syntax.css" rel="stylesheet" ><ul id="markdown-toc"><li><a href="#intro" id="markdown-toc-intro">Intro</a></li><li><a href="#problems" id="markdown-toc-problems">Problems</a><ul><li><a href="#21" id="markdown-toc-21">2.1</a></li><li><a href="#22" id="markdown-toc-22">2.2</a></li><li><a href="#23" id="markdown-toc-23">2.3</a></li><li><a href="#24" id="markdown-toc-24">2.4</a></li><li><a href="#25" id="markdown-toc-25">2.5</a></li><li><a href="#26" id="markdown-toc-26">2.6</a></li><li><a href="#27" id="markdown-toc-27">2.7</a></li><li><a href="#28" id="markdown-toc-28">2.8</a></li><li><a href="#29" id="markdown-toc-29">2.9</a></li><li><a href="#210" id="markdown-toc-210">2.10</a></li></ul></li></ul><h2 id="intro">Intro</h2><p>My solutions to the practice problems in “Understanding Cryptography: A Textbook for Students and Practitioners - Chapter 2”.</p><p>The solution scripts to some of the problems have been uploaded to GitHub, you can check them out at: <a href="https://github.com/yype/UnderstandingCrypto" target="_blank">https://github.com/yype/UnderstandingCrypto</a>.</p><h2 id="problems">Problems</h2><h3 id="21">2.1</h3><p>(1) The key could look like a stream of letters from A~Z, which represent keys between 0~25.</p>\[y_i=e_{k_i}(x_i)=x_i+k_i\bmod26\\ x_i=d_{k_i}(y_i)=y_i-k_i\bmod26\\\]<p>(2) I found this problem strange at first, and later, according to the Internet, I found that the key provided in the book is wrong. The correct key should be <code class="highlighter-rouge">rsidpy dkawoy</code>.</p><p>Solution script:</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">enc</span> <span class="o">=</span> <span class="s">'bsaspp kkuosp'</span>
<span class="n">key</span> <span class="o">=</span> <span class="s">'rsidpy dkawoy'</span>  <span class="c1"># the key in the book is wrong
</span>
<span class="n">dec</span> <span class="o">=</span> <span class="s">''</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">enc</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">enc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">' '</span><span class="p">:</span>
        <span class="n">e</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">enc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>
        <span class="n">dec</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(((</span><span class="n">e</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="mi">26</span><span class="p">)</span><span class="o">+</span><span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dec</span> <span class="o">+=</span> <span class="s">' '</span>

<span class="k">print</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
</code></pre></div></div><p>Output:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kaspar hauser
</code></pre></div></div><p>(3) According to <a href="https://en.wikipedia.org/wiki/Kaspar_Hauser">this</a>, it seems that Hauser died of a fatal stab wound on 17 December 1833.</p><h3 id="22">2.2</h3><p>(1) Life cycle of the key: Every single bit in the key should never be reused.</p><p>(2) Storage of the key during the life cycle: The key must be stored at both the sending and receiving end.</p><p>(3) Storage of the key after the life cycle: They must be destroyed since all former encrypted data will become vulunerable if these keys are leaked in the future.</p><p>(4) Key distribution: The safest way, in my point of view, is to make only 2 copies of the key in the world, and to distribute the keys physically(without being intercepted by any 3rd parties).</p><p>(5) Generation of the key: A TRNG should be used. Or else it will be the same as using a normal stream cipher along with a PRNG, and just distributing the key of the PRNG.</p><h3 id="23">2.3</h3><p>When 128 bits of the plaintext($x_0$~$x_{127}$) and their corresponding cipher bits($y_0$~$y_{127}$) are known to an attacker, he/she/it can easily calculate the key bits($k_0$~$k_{127}$) used in the encryption process:</p>\[k_i=x_i\oplus y_i,i=0,1,...,127\]<h3 id="24">2.4</h3><p>The attacker will have no idea which key should be correct, so any brute-force attack is meaningless. Each key guessed can be used to decrypt the ciphertext, generating a plaintext(plaindata). There is no way the attacker can know which key is right and if the plaintext decrypted is the original one.</p><h3 id="25">2.5</h3><p>(1)</p>\[(c_2=1,c_1=0,c_0=1)\\ \text{}\\ \begin{array}{|c|c c c|} \text{Clk} &amp; FF_2 &amp; FF_1 &amp; FF_0=s_i \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1 &amp; 0 \\ 2 &amp; 1 &amp; 1 &amp; 1 \\ 3 &amp; 0 &amp; 1 &amp; 1 \\ 4 &amp; 1 &amp; 0 &amp; 1 \\ 5 &amp; 0 &amp; 1 &amp; 0 \\ 6 &amp; 0 &amp; 0 &amp; 1 \\ 7 &amp; 1 &amp; 0 &amp; 0 \\ \end{array}\\\]<p>So the sequence is (<code class="highlighter-rouge">0011101</code>)*.</p><p>(2)</p>\[(c_2=1,c_1=0,c_0=1)\\ \text{}\\ \begin{array}{|c|c c c|} \text{Clk} &amp; FF_2 &amp; FF_1 &amp; FF_0=s_i \\ 0 &amp; 0 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 0 &amp; 1 \\ 2 &amp; 0 &amp; 1 &amp; 0 \\ 3 &amp; 0 &amp; 0 &amp; 1 \\ 4 &amp; 1 &amp; 0 &amp; 0 \\ 5 &amp; 1 &amp; 1 &amp; 0 \\ 6 &amp; 1 &amp; 1 &amp; 1 \\ 7 &amp; 0 &amp; 1 &amp; 1 \\ \end{array}\\\]<p>So the sequence is (<code class="highlighter-rouge">1101001</code>)*.</p><p>(3) <strong>a)</strong> Their periods are the same. <strong>b)</strong> <code class="highlighter-rouge">S2</code> can be viewed as <code class="highlighter-rouge">ROL(S1, 3)</code>, where <code class="highlighter-rouge">S1/S2</code> represent the repetends of the first and second sequence.</p><h3 id="26">2.6</h3><p>One possible attack: I will need to know 25 bytes(letters), which is <code class="highlighter-rouge">200(bits) / 8(bits/byte)</code>, of the ciphertext and their corresponding plaintext. Then I will be able to calculate 200 bits of the key sequence used($k_i=\text{plainbit}_i\oplus\text{cipherbit}_i$).</p><p>After that, all left to do is to determine the actual keysize. We can simply run several brute-force decryptions, starting from the first plaintext bit we know, using the first $k$ bits of the 200 key bits calculated, where $k=150,151,…,200$.</p><p>It should be noted that if the keysize used is not correct, there is a great chance that the data decrypted is not readable(printable) ASCII text. As a result, once we successfully decrypt the ciphertext and get a readable plaintext after the 25th byte, we know what the actual keysize is.</p><h3 id="27">2.7</h3><p>The chosen LFSR’s polynomial is <code class="highlighter-rouge">(0,1,3,4,8)</code>. I wrote a simple script to help me with the calculation, and the resulting first two output bytes can be viewed as a little endian number <code class="highlighter-rouge">0x90ff</code>.</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chapt2&gt; py .\p2.7.py
0x90ff
</code></pre></div></div><h3 id="28">2.8</h3><p>(1) Draw the corresponding LFSR for each of the three polynomials.</p><p>I don’t want to draw them :P</p><p>(2) I wrote a script to calculate all the possible initial values and their corresponding sequence lengh, it outputs as follows:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chapt2&gt; py .\p2.8.py
Polynomial: (0, 1, 4)
init            len(seq)
1               15
2               15
3               15
4               15
5               15
6               15
7               15
8               15
9               15
10              15
11              15
12              15
13              15
14              15
15              15

Polynomial: (0, 2, 4)
init            len(seq)
1               6
2               6
3               6
4               6
5               6
6               3
7               6
8               6
9               6
10              6
11              3
12              6
13              3
14              6
15              6

Polynomial: (0, 1, 2, 3, 4)
init            len(seq)
1               5
2               5
3               5
4               5
5               5
6               5
7               5
8               5
9               5
10              5
11              5
12              5
13              5
14              5
15              5
</code></pre></div></div><p>We can see that, the first polynomial $x^4+x+1$ can generate a maximum-length($2^4-1=15$) sequence, so it is a primitive polynomial. The second polynomial $x^4+x^2+1$ does not generate a maximum-length sequence and its sequence length depends on its initial value, so it is an irreducible polynomial. The third polynomial $x^4+x^3+x^2+x+1$ does not generate a maximum-length sequence, but its sequence length stays the same despite the changing initial value, so it is a reducible polynomial.</p><h3 id="29">2.9</h3><p>(1) $256\times2=512\text{(bits)}$.</p><p>(2) Let the known plaintext bits be given by $x_0,x_1,…,x_{511}$ and the corresponding ciphertext bits by $y_0,y_1,…,y_{511}$. With these 512 pairs of plaintext and ciphertext bits, we can reconstruct the first 512 key stream bits:</p>\[s_i=x_i\oplus y_i,i=0,1,...,511\]<p>Our goal is to find the key bits given by the feedback coefficients $p_i$. The relationship between the unknown key bits $p_i$ and the key stream bits $s_i$ can be described as follows:</p>\[s_{i+256}=\sum_{j=0}^{255}{p_j\cdot s_{i+j}}, i=0,1,...,255\]<p>This actually represents 256 linearly independent formulae, which contain 256 unknown variables $p_0,p_1,…,p_255$. This system can be easily solved using Gaussian elimination, matrix inversion or any other algorithm for solving systems of linear equations.</p><p>(3.a) The key is $p_0,p_1,…,p_{255}$.</p><p>(3.b) If we use the initial contents of the LFSR as the key, the attacker can get the key almost without performing any attack since the first 256 bits of the <strong>key stream bits</strong> are exactly the same as the initial content bits. If we use the initial contents of the LFSR as part of the key, the part that takes actual effect will be just the initial content, so any other bits in the key will be useless, then the situation becomes no different as just using the initial contents as the key.</p><h3 id="210">2.10</h3><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Plaintext bits:  `1001 0010 0110 1101 1001 0010 0110`
Ciphertext bits: `1011 1100 0011 0001 0010 1011 0001` 
</code></pre></div></div><p>So we can get the key stream bits: <code class="highlighter-rouge">0010 1110 0101 1100 1011 1001 0111</code>.</p><p>We can clearly observe its repetend: <code class="highlighter-rouge">0010111</code>. Let’s suppose it’s generated by a primitive polynomial, then the degree should be $m=\log_2{(7+1)}=3$. Next we test if there are indeed $2^m-1=7$ sequence states. As for the key stream bits, the states are as follows:</p>\[\begin{array}{|c|c c c|} \text{Clk} &amp; FF_2 &amp; FF_1 &amp; FF_0=s_i \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 1 &amp; 0 \\ 2 &amp; 1 &amp; 0 &amp; 1 \\ 3 &amp; 1 &amp; 1 &amp; 0 \\ 4 &amp; 1 &amp; 1 &amp; 1 \\ 5 &amp; 0 &amp; 1 &amp; 1 \\ 6 &amp; 0 &amp; 0 &amp; 1 \\ 7 &amp; 1 &amp; 0 &amp; 0 \\ \end{array}\\\]<p>We can see that there are 7 sequence states(the sequence length is 7). Therefore, <em>it’s possible</em>, that the LFSR could be using a primitive polynomial of degree 3.</p><blockquote><p>Note that we can never know if the key stream contains a larger repetend. Using the given information, we can only be sure that <em>an LFSR using a primitive polynomial of degree 3</em> could be possible. There is a possibility that an LFSR using a polynomial of a larger degree is actually used. Specifically for this problem, I’ll just assume the degree is 3.</p></blockquote><p>(1) What is the degree m of the key stream generator?</p><p>It’s 3.</p><p>(2) What is the initialization vector?</p><p>It’s <code class="highlighter-rouge">100</code>.</p><p>(3) Determine the feedback coefficients of the LFSR.</p><p>To break the cipher we only need to use $2m=6$ key stream bits, let’s grab the first 6 bits of the key stream. Let the coefficients be $p_0,p_1,p_2$, then we have:</p>\[s_3=s_0p_0+s_1p_1+s_2p_2\\ s_4=s_1p_0+s_2p_1+s_3p_2\\ s_5=s_2p_0+s_3p_1+s_4p_2\]<p>which can be denoted as:</p>\[\begin{bmatrix} 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} p_0\\ p_1\\ p_2 \end{bmatrix} = \begin{bmatrix} 0\\1\\1 \end{bmatrix}\]<p>We can calculate $P$ by:</p>\[\begin{aligned} P= \begin{bmatrix} p_0\\ p_1\\ p_2 \end{bmatrix} &amp;=\begin{bmatrix} 0 &amp; 0 &amp; 1\\ 0 &amp; 1 &amp; 0\\ 1 &amp; 0 &amp; 1 \end{bmatrix}^{-1} \begin{bmatrix} 0\\1\\1 \end{bmatrix}\\ &amp;= \begin{bmatrix} -1&amp;0&amp;1\\ 0&amp;1&amp;0\\ 1&amp;0&amp;0 \end{bmatrix} \begin{bmatrix} 0\\1\\1 \end{bmatrix}\\ &amp;= \begin{bmatrix} 1\\1\\0 \end{bmatrix} \end{aligned}\]<p>So the coefficients are: $p_0=1,p_1=1,p_2=0$, the polynomial used is $x^3+x+1$.</p><p>(4.a)</p><p>I don’t want to draw the circuit diagram :P</p><p>(4.b)</p><p>I wrote a script to help with the key stream generation and the coefficient verification, see the corresponding solution script for more detail.</p><span class="meta"><time datetime="2021-01-26T00:00:00+08:00">January 26, 2021</time> &middot; <a href="/tag/Crypto">Crypto</a>, <a href="/tag/Understanding Cryptography">Understanding Cryptography</a></span></section></main></body><script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true } }); </script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ CommonHTML: { scale: 90 }, "HTML-CSS": { scale: 90 }, NativeMML: { scale: 90 }, SVG: { scale: 90 }, PreviewHTML: { scale: 90 } }); </script></html>
