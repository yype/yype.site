[
  
    {

      "title"    : "N1CTF2020 n1vault, thoughts &amp; solutions",
      "url"      : "/2020/10/23/n1vault",
      "category" : "",
      "tags"     : "CTF, Reverse Engineering, N1CTF2020",
      "date"     : "2020-10-23 00:00:00 +0800",
      "description" : "",
      "content"  : "IntroI designed the RE challenge n1vault in the recent CTF N1CTF2020, in this post I will talk about details about this chal and offer some possible solutions.The core part of this challenge is to craft a file’s CRC to an arbitrary value(zero) by modifying some specified bytes of the same bit size as the CRC value.As for the binary n1vault, it uses SHA256 to digest all the bytes inside the file(credencial.png) except for the even bytes in the last 25 bytes(some twists were added to the sha256_update function, paving the way for the backdoor), once the file’s CRC has been faked to 0, a secret logic(backdoor) will be triggered by an exception FPE_INTDIV, since the verification inside function main has an unnecessary comparison 4764888639493207598 / (crc32_result | crc64_result) == 1, which will trigger an FPE_INTDIV when both crc32_result and crc64_result are zero, and will be evaluated to true when given the original file credential.png. Players’ job is to to craft an input to trigger the backdoor, send the crafted bytes to the judging bot and receive the flag.SolutionThe reverse engineering part of the binary program is quite easy, some junks with fixed patterns are inserted into the main logic, which can be bypassed by simple searching amp; replacing. After that the program logic is really straightforward, we only have to solve the math problem left.CRC has a property that the final result can be viewed as the linear combination of the influence of each bit in the message and an initial bias, based on GF(2), which can be described as:#92;hhhhhhhhhhhh(f(x)=f(0) + #92;hhhhhhhhhhhhsum_i=0^CRC#92;hhhhhhhhhhhh_SIZE-1 x_i #92;hhhhhhhhhhhhcdot #92;hhhhhhhhhhhhmboxinfluence(i),#92;hhhhhhhhhhhh)where f(0) is the initial bias, specifically for this challenge, is the CRC of the credential with all the even bytes in the last 25 bytes set to zero. Given this property, if we have enough x_i to control, we can easily construct a matrix and solve each x_i using gauss elimination. The twist here is that we have to ensure both f(x)=CRC32(credential) and g(x)=CRC64(credential) are equal to zero. Actually if we let h(x)=(f(x) lt; lt; 64)+g(x) and focus our attention on making h(x)=0, it has the same effect as making both f(x) and g(x) zero.I write a tool based on this interesting property of CRC, allowing us to arbitrarily craft a file’s CRC by specifying certain bits available for modification. It can output all the available solutions and allows for fewer available bits than the bit size of the CRC result. You can check the tool here:  https://github.com/yype/crcolliderUsing this tool we can easily solve the problem using the following Python code:from crcollider import collcrcfrom crc_funcs import crc64, crc32def crc96(m):    return (crc32(m) lt;lt; 64) + crc64(m)def solve_chal():    with open(&#39;credential.png&#39;, &#39;rb&#39;) as f:        org_img = f.read()    rg = list(range(len(org_img)*8))    available_bits = []    for i in range(12):        # even bytes in the last 25 bytes        available_bits += rg[len(rg)-16*i-16:len(rg)-16*i-8]    sol_num, sols = collcrc(crc96, 96, org_img, available_bits, 0x0)        print(f&#39;sol_num solution(s) found&#39;)    for i, each in enumerate(sols):        file_out = f&#39;credential_soli.png&#39;        print(f&#39;Outputting soli to file_out...&#39;)        with open(file_out, &#39;wb&#39;) as f:            f.write(each)if __name__ == &#39;__main__&#39;:    solve_chal()There are totally 4 solutions available for this challenge. One of them contains only visible characters, which is n1vaultadmin(intentionally crafted), while others are not. It might be better if I put some constraints to ensure that only one solution is available though.solutiongt; python3 .#92;hhhhhhhhhhhhmain.py4 solution(s) foundOutputting sol0 to credential_sol0.png...Outputting sol1 to credential_sol1.png...Outputting sol2 to credential_sol2.png...Outputting sol3 to credential_sol3.png...You can also check the awesome write-up from team Super Guesser who got the first blood of this challenge here: https://gist.github.com/jhs7jhs/cb5fedc1ffb6138b73420cb8567357bb#n1vault.The source code of this challenge and a duplicate of this post are uploaded to GitHub, check them out at: https://github.com/Nu1LCTF/n1ctf-2020/tree/main/RE/n1vault."

    } ,
  
    {

      "title"    : "PlaidCTF2020 The Watness 2 Write-up",
      "url"      : "/2020/04/20/hypercard-over-windows",
      "category" : "",
      "tags"     : "Write-up, Reverse Engineering, Hypercard, CTF, PlaidCTF2020",
      "date"     : "2020-04-20 00:00:00 +0800",
      "description" : "",
      "content"  : "IntroRecently in PlaidCTF2020 there was a RE challenge called The Watness 2, which is a game that requires the application HyperCard to run. Since I did not have a Macbook computer, I’d been struggling figuring out ways to run this game over my Windows 10 laptop. Here is how I finally managed to do that.Steps  Follow this great video tutorial  Download StuffitExpander, add it to the volumes’ list, install it inside the VM:  Download HyperCard 2.4, install it inside the VM as described above  Extract the .rc1 file from the .sit file and open it with a simple double-click:Challenge SolutionExtract the stack’s script code:on openCard  Send colorMe to this card  pass openCardend openCardon closeCard  global prev_card  get the id of this cd  put it into prev_card  lock screen  pass closeCardend closeCardon colorMe  AddColor colorCard,stamp,0end colorMeon openStack  AddColor install  setupMenu  go to card tun-1-n  pass openStackend openStackon closeStack  AddColor remove  pass closeStackend closeStackon genPuzzle  send doMenu New Button to Hypercardend genPuzzleon initCard  answer prev_cardend initCardon menuReset  setupMenu  pass menuResetend menuReseton setupMenu  if there is not a menu Watness then    create menu Watness    put Generate Puzzleamp;returnamp;Init Cardamp;returnamp;Set up Navamp;returnamp;Create Puzzle into menu Watness with menuMsg genPuzzle,initCard,setupNav,constructPuzzle  end ifend setupMenuon setupNav  ask What is the name of this card  set name of this cd to it    ask Where should the left go?  put it into left_loc  send doMenu New Button to Hypercard  set height of the last button to 342  set width of the last button to 100  set topleft of the last button to 0,0  set style of the last button to transparent  set name of the last button to   put on mouseUpamp;returnamp;go to card amp;quoteamp;amp;left_locamp;quoteamp;returnamp;end mouseUp into left_script  set script of last button to left_script    ask Where should the right go?  put it into right_loc  send doMenu New Button to Hypercard  set height of the last button to 342  set width of the last button to 100  set topleft of the last button to 412,0  set style of the last button to transparent  set name of the last button to   put on mouseUpamp;returnamp;go to card amp;quoteamp;amp;right_locamp;quoteamp;returnamp;end mouseUp into right_script  set script of last button to right_script    ask Where should fwd go?  put it into fwd_loc  send doMenu New Button to Hypercard  set height of the last button to 342  set width of the last button to 311  set the top of the last button to 0  set the left of the last button to 100  set style of the last button to transparent  set name of the last button to   put on mouseUpamp;returnamp;go to card amp;quoteamp;amp;fwd_locamp;quoteamp;returnamp;end mouseUp into fwd_script  set script of last button to fwd_script    get the script of this card  put it into cd_script  put cd_scriptamp;return into cd_script  put cd_scriptamp;on arrowKey keyamp;return into cd_script  put cd_scriptamp; if key = amp;quoteamp;leftamp;quoteamp;thenamp;return into cd_script  put cd_scriptamp;  go to cd amp;quoteamp;left_locamp;quoteamp;return into cd_script  put cd_scriptamp; end ifamp;return into cd_script  put cd_scriptamp; if key = amp;quoteamp;rightamp;quoteamp;thenamp;return into cd_script  put cd_scriptamp;  go to cd amp;quoteamp;right_locamp;quoteamp;return into cd_script  put cd_scriptamp; end ifamp;return into cd_script  put cd_scriptamp; if key = amp;quoteamp;upamp;quoteamp;thenamp;return into cd_script  put cd_scriptamp;  go to cd amp;quoteamp;fwd_locamp;quoteamp;return into cd_script  put cd_scriptamp; end ifamp;return into cd_script  put cd_scriptamp;end arrowKeyamp;return into cd_script      set the script of this cd to cd_scriptend setupNavon makeNode  global node  send doMenu New Button to Hypercard  put the id of the last button into nodeend makeNodeon constructPuzzle  global node,constraints    ask What are the constraints  put it into constraints    get the script of this cd  put it into cd_script  put cd_scriptamp;return into cd_script  put cd_scriptamp;on openCardamp;return into cd_script  put cd_scriptamp;  global constraints,path,cursor_x,cursor_y, into cd_script    put 0 into i  repeat for 8        put 0 into j    repeat for 8      put cd_scriptamp;active_amp;iamp;_amp;jamp;, into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put cd_scriptamp;dummyamp;return into cd_script  put cd_scriptamp;  colormeamp;return into cd_script  put cd_scriptamp;  put -1 into cursor_xamp;return into cd_script  put cd_scriptamp;  put 0 into cursor_yamp;return into cd_script  put cd_scriptamp;  put amp;quoteamp;quoteamp; into pathamp;return into cd_script  put cd_scriptamp;  put amp;quoteamp;constraintsamp;quoteamp; into constraintsamp;return into cd_script    put 1 into c_i  put 0 into i  repeat for 7        put 0 into j    repeat for 7      get char (j*7+i+1) of constraints      put it into letter            if letter lt;gt;   then        makeNode                set the width of button id node to 10        set the height of button id node to 10                set the top of button id node to (76 + j * 30)        set the left of button id node to (161 + i * 30)                set the style of button id node to opaque        set showName of button id node to false                if letter = r then          put 65535,0,0 into node_color        end if        if letter = g then          put 0,65535,0 into node_color        end if        if letter = b then          put 0,0,65535 into node_color        end if                if letter lt;gt;   then          addColor colorButton, cd, node, node_color                    put cd_scriptamp;  addColor colorButton, cd, amp;nodeamp;, amp;quoteamp;node_coloramp;quoteamp;return into cd_script        end if      end if                        put j+1 into j    end repeat        put i+1 into i  end repeat        put 0 into i  repeat for 8        put 0 into j    repeat for 8      put cd_scriptamp;  put amp;quoteamp;quoteamp; into active_amp;iamp;_amp;jamp;return into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    makeNode    set the width of button id node to 10  set the height of button id node to 15  set the left of button id node to 356  set the top of button id node to 276  set the name of button id node to path_extension  set showName of button id node to false  set the style of button id node to opaque  addcolor colorButton, cd, node, 37632,30208,12288    put  into node_script  put node_scriptamp;on checkYoSelfamp;return into node_script  put node_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script  put node_scriptamp;end checkYoSelfamp;return into node_script    set the script of button id node to node_script    put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script      makeNode    set the width of button id node to 10  set the height of button id node to 10  set the left of button id node to 356  set the top of button id node to 286  set the name of button id node to finale  set showName of button id node to false  set the style of button id node to oval  addcolor colorButton, cd, node, 37632,30208,12288    put  into node_script  put node_scriptamp;on mouseUpamp;return into node_script  put node_scriptamp;  global cursor_x, cursor_yamp;return into node_script  put node_scriptamp;  if (cursor_x = 7) and (cursor_y = 7) thenamp;return into node_script  put node_scriptamp;    addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script  put node_scriptamp;    send amp;quoteamp;checkYoSelfamp;quoteamp; to button path_extensionamp;return into node_script  put node_scriptamp;    send amp;quoteamp;checkSolutionamp;quoteamp; to this cdamp;return into node_script  put node_scriptamp;  end ifamp;return into node_script  put node_scriptamp;end mouseUpamp;return into node_script    set the script of button id node to node_script    put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script    put 0 into i  repeat for 7        put 0 into j    repeat for 8      makeNode            set the width of button id node to 30      set the height of button id node to 10            set the top of button id node to (61 + 30 * j)      set the left of button id node to (151 + 30 * i)            set the style of button id node to opaque      set the name of button id node to h_path_amp;iamp;_amp;j            set showName of button id node to false            addcolor colorButton, cd, node, 37632,30208,12288            put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script            get the script of button id node      put it into node_script            put active_amp;iamp;_amp;j into f_node      put active_amp;(i+1)amp;_amp;j into s_node            put node_scriptamp;return into node_script      put node_scriptamp;on checkYoSelfamp;return into node_script      put node_scriptamp;  global amp;f_nodeamp;,amp;s_nodeamp;return into node_script      put node_scriptamp;  if (amp;f_nodeamp; = true) and (amp;s_nodeamp; = true) thenamp;return into node_script      put node_scriptamp;    addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script      put node_scriptamp;  end ifamp;return into node_script      put node_scriptamp;end checkYoSelfamp;return into node_script            set the script of button id node to node_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put 0 into i  repeat for 8        put 0 into j    repeat for 7      makeNode            set the width of button id node to 10      set the height of button id node to 30            set the top of button id node to (66 + 30 * j)      set the left of button id node to (146 + 30 * i)            set the style of button id node to opaque      set the name of button id node to v_path_amp;iamp;_amp;j            set showName of button id node to false            addcolor colorButton, cd, node, 37632,30208,12288            put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script            get the script of button id node      put it into node_script            put active_amp;iamp;_amp;j into f_node      put active_amp;iamp;_amp;(j+1) into s_node            put node_scriptamp;return into node_script      put node_scriptamp;on checkYoSelfamp;return into node_script      put node_scriptamp;  global amp;f_nodeamp;,amp;s_nodeamp;return into node_script      put node_scriptamp;  if (amp;f_nodeamp; = true) and (amp;s_nodeamp; = true) thenamp;return into node_script      put node_scriptamp;    addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script      put node_scriptamp;  end ifamp;return into node_script      put node_scriptamp;end checkYoSelfamp;return into node_script            set the script of button id node to node_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put 0 into i  repeat for 8        put 0 into j    repeat for 8      makeNode            set the width of button id node to 10      set the height of button id node to 10            set the top of button id node to (61 + 30 * j)      set the left of button id node to (146 + 30 * i)            set the style of button id node to oval      set the name of button id node to button_amp;iamp;_amp;j            set showName of button id node to false            addcolor colorButton, cd, node, 37632,30208,12288            put active_amp;iamp;_amp;j into v_name            put  into node_script      put node_scriptamp;on mouseUpamp;return into node_script      put node_scriptamp;  global amp;v_nameamp;,cursor_x,cursor_yamp;return into node_script      put node_scriptamp;  put cursor_x into prev_xamp;return into node_script      put node_scriptamp;  put cursor_y into prev_yamp;return into node_script      put node_scriptamp;  put abs(cursor_x-amp;iamp;) into dxamp;return into node_script      put node_scriptamp;  put abs(cursor_y-amp;jamp;) into dyamp;return into node_script      put node_scriptamp;  if (amp;v_nameamp; = amp;quoteamp;quoteamp;) and ((dx = 1 and dy = 0) or (dx = 0 and dy = 1)) thenamp;return into node_script      put node_scriptamp;    put true into amp;v_nameamp;return into node_script      put node_scriptamp;    send amp;quoteamp;updateState amp;iamp;,amp;jamp;quoteamp; to this cdamp;return into node_script      put node_scriptamp;    addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script      put node_scriptamp;  end ifamp;return into node_script      put node_scriptamp;end mouseUpamp;return into node_script            set the script of button id node to node_script            put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    set the width of button button_0_0 to 30  set the height of button button_0_0 to 30    set the top of button button_0_0 to 51  set the left of button button_0_0 to 136    get the id of button button_0_0  addColor colorButton, cd, it, 37632,30208,12288    put cd_scriptamp;end openCardamp;return into cd_script  set the script of this cd to cd_script  end constructPuzzleon checkSolution  global puzzle_id,path,constraints,flag_1,flag_2,flag_3  watnesssolver constraints,path  put the result into success  if success = true then    if puzzle_id = 1 then      decoder path,clrtffxpry      put the result into flag_1    end if    if puzzle_id = 2 then      decoder path,nyghq7xksg      put the result into flag_2    end if    if puzzle_id = 3 then      decoder path,ppyyvn17      put the result into flag_3    end if  else    send opencard to this cd  end ifend checkSolutionon updateState i,j  global path,cursor_x,cursor_y    if (i lt;gt; 0) or (j lt;gt; 0) then    if (cursor_y = j+1) and (cursor_x = i) then      put pathamp;U into path    end if    if (cursor_y = j) and (cursor_x = i - 1) then      put pathamp;R into path    end if    if (cursor_y = j-1) and (cursor_x = i) then      put pathamp;D into path    end if    if (cursor_y = j) and (cursor_x = i + 1) then      put pathamp;L into path    end if  end if      if cursor_x gt;= 0 and cursor_y gt;= 0 then    put h_path_amp;min(cursor_x, i)amp;_amp;min(cursor_y, j) into h_path    put v_path_amp;min(cursor_x, i)amp;_amp;min(cursor_y, j) into v_path        if i = cursor_x then      send checkYoSelf to button v_path    end if        if j = cursor_y then      send checkYoSelf to button h_path    end if      end if    put i into cursor_x  put j into cursor_yend updateStateThe card’s script code can also be extracted (puzzle 1):on openCard  global puzzle_id,constraints,path,cursor_x,cursor_y,active_0_0,active_0_1,active_0_2,active_0_3,active_0_4,active_0_5,active_0_6,active_0_7,active_1_0,active_1_1,active_1_2,active_1_3,active_1_4,active_1_5,active_1_6,active_1_7,active_2_0,active_2_1,active_2_2,active_2_3,active_2_4,active_2_5,active_2_6,active_2_7,active_3_0,active_3_1,active_3_2,active_3_3,active_3_4,active_3_5,active_3_6,active_3_7,active_4_0,active_4_1,active_4_2,active_4_3,active_4_4,active_4_5,active_4_6,active_4_7,active_5_0,active_5_1,active_5_2,active_5_3,active_5_4,active_5_5,active_5_6,active_5_7,active_6_0,active_6_1,active_6_2,active_6_3,active_6_4,active_6_5,active_6_6,active_6_7,active_7_0,active_7_1,active_7_2,active_7_3,active_7_4,active_7_5,active_7_6,active_7_7,dummy  colorme  put 1 into puzzle_id  put -1 into cursor_x  put 0 into cursor_y  put  into path  put rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg into constraints  addColor colorButton, cd, 1, 65535,0,0  ...end openCardon arrowKey key  if key = leftthen    go to cd entry-3-n  end if  if key = rightthen    go to cd entry-3-n  end if  if key = upthen    go to cd   end ifend arrowKeyNow we get the constraint string of this puzzle rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg, these constraints, along with the path that goes to the lower right corner, are passed into one thing called XCMD which checks the path’s correctness natively (it contains binary instructions that directly run over the 68k CPU). There are 2 XCMD binaries which can be extracted by this tool, which seem can only run under MacOS. So I’m using the extracted binary from this great post for now instead.What’s more, I found that I can set breakpoints in the script and debug the game, I could even watch the variables on the fly:As for the XCMD part, it’s basically just a few hours’ reverse engineering work. Since there are currently no reliable decompilers for the 68k architecture, I have to read the assembly. It wasn’t too hard, but I did spend several hours learning the basic concepts of 68k’s instruction set.After the reverse engineering work, the watnesssolver’s checking methods can be rewritten in Python as:def build_automaton(constraints: str):    trans = str.maketrans(&#39; rgb&#39;, &#39;0123&#39;)    return [int(c) for c in constraints.translate(trans)]def choose_empty(r, g, b):    if g == 0 and b == 0:        return 0    if b lt; g:        return 2    else:        return 3def choose_red(r, g, b):    if r != 2 and r != 3:        return 0    if b == 0 or g == 0:        return 0    return 1def choose_green(r, g, b):    if r lt;= 4:        if b lt;= 4:            if r == 2 or r == 3:                return 1            else:                return 2        else:            return 3    else:        return 0def choose_blue(r, g, b):    if r lt;= 4:        if g lt;= 4:            if r == 2 or r == 3:                return 1            else:                return 3        else:            return 2    else:        return 0def is_red(constraints, x, y):    if not (x gt;= 0 and x lt; 7 and y gt;= 0 and y lt; 7):        return False    return constraints[x+y*7] == 1def get_neighbors(constraints, x, y, color):    sum = 0    for bias_y in range(-1, 2):        for bias_x in range(-1, 2):            if (bias_x != 0 or bias_y != 0) and (y + bias_y gt;= 0 and y + bias_y lt; 7) and #92;hhhhhhhhhhhh                    (x + bias_x gt;= 0 and x + bias_x lt; 7) and constraints[(x+bias_x)+(y+bias_y)*7] == color:                sum += 1    return sumdef step_automaton(constraints):    new_constraints = constraints[:]    for y in range(7):        for x in range(7):            r, g, b = #92;hhhhhhhhhhhh                get_neighbors(constraints, x, y, 1), #92;hhhhhhhhhhhh                get_neighbors(constraints, x, y, 2), #92;hhhhhhhhhhhh                get_neighbors(constraints, x, y, 3)            if constraints[x+y*7] == 0:                new_constraints[x+y*7] = choose_empty(r, g, b)            elif constraints[x+y*7] == 1:                new_constraints[x+y*7] = choose_red(r, g, b)            elif constraints[x+y*7] == 2:                new_constraints[x+y*7] = choose_green(r, g, b)            elif constraints[x+y*7] == 3:                new_constraints[x+y*7] = choose_blue(r, g, b)    return new_constraintsdef perform_move(constraints, mem, x, y, d):    bias_x, bias_y = 0, 0    if d == &#39;U&#39;:        bias_x, bias_y = 0, -1    elif d == &#39;D&#39;:        bias_x, bias_y = 0, 1    elif d == &#39;L&#39;:        bias_x, bias_y = -1, 0    elif d == &#39;R&#39;:        bias_x, bias_y = 1, 0    if not (x+bias_x gt;= 0 and x+bias_x lt; 8 and y+bias_y gt;= 0 and y+bias_y lt; 8):        return False, x, y    min_x = min(x, x+bias_x)    min_y = min(y, y+bias_y)    if bias_y == 0:        if not (is_red(constraints, min_x, y) or is_red(constraints, min_x, y-1)):            return False, x, y    else:        if not (is_red(constraints, x, min_y) or is_red(constraints, x-1, min_y)):            return False, x, y    if mem[x+bias_x][y+bias_y] == 1:        return False, x, y    mem[x+bias_x][y+bias_y] = 1    return True, x+bias_x, y+bias_ydef solver(path, constraints):    x = y = 0    constraints = build_automaton(constraints)    mem = [[0 for i in range(8)] for j in range(8)]  # been to or not    mem[0][0] = 1    for each in path:        yes, new_x, new_y = perform_move(constraints, mem, x, y, each)        if yes:            if new_x == 7 and new_y == 7:                # print(f&#39;Path `path` is great &#39; + &#39;!&#39; * 20)                return True, True            x, y = new_x, new_y            constraints = step_automaton(constraints)        else:            #print(f&#39;Path `path` is bad&#39;)            return False, False    return True, FalseLooking around in the game, we’ll know that there are 3 puzzles we need to solve. So we can simply run 3 DFS searches on these contraints and three unique solutions will be printed out.def dfs(depth, path, constraints):    if depth gt; 24: # figured out after multiple tests        return    mov, end = solver(path, constraints)    if end == True:        print(f&#39;Path path is ok&#39;)    if mov == False:        return    for d in &#39;LRUD&#39;:        n_path = path + d        dfs(depth+1, n_path, constraints)if __name__ == &#39;__main__&#39;:    constraints_stage1 = &#39;rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg&#39;    constraints_stage2 = &#39;rbr  bbggrgrggb   bggbb b  b bbrbbgg gbrrbgrbbb g&#39;    constraints_stage3 = &#39;rrbrb rg g  bgrbgggr ggrgr gr rg brr  b  bggrbgbb&#39;    print(&#39;Stage1 solution:&#39;)    dfs(0, &#39;&#39;, constraints_stage1)    print(&#39;Stage2 solution:&#39;)    dfs(0, &#39;&#39;, constraints_stage2)    print(&#39;Stage3 solution:&#39;)    dfs(0, &#39;&#39;, constraints_stage3)Output:Stage1 solution:Path RDDDRURRRDLLDLDRRURRDDDR is okStage2 solution:Path RDDRURDDDRURULURRDDDDDRD is okStage3 solution:Path DRDDDDRUURRRULURRDDDDDDR is okInput these solutions to each puzzle, after that, we could go to the lock-like thing on the white gate to reveal the flag:"

    } ,
  
    {

      "title"    : "Write Invalid and Cache Coherence",
      "url"      : "/2020/03/12/write-invalid-and-cache-coherence",
      "category" : "",
      "tags"     : "distributed computing, cache coherence, write-invalid, class notes",
      "date"     : "2020-03-12 00:00:00 +0800",
      "description" : "",
      "content"  : "// This post was written in ChineseIntro今天分布式听飘了，个人感觉老师放的课件对问题的描述以及解答有些欠缺，后来做了些资料检索，对下面这个简单问题做了些总结：对于 write-update、write-invalidate 两种 coherence protocol，哪一种在生产消费者模型下的性能更差？首先得知道 coherence protocol 的目的是什么，它的目的很简单：保证多处理器系统下的数据一致性。有两类这种协议，一种是 snoopy-based 另一种是 directory-based（当然还有一个 shared caches 概念这里也不讨论了），对于前者来说，所有读写、更新操作都以类似广播的方式发给所有处理器，每个处理器相应地 snoop and respond，write-update 和 write-invalid 都是属于这一类，这两种方式的定义分别如下：  Write-update: When a write operation is observed to a location that a cache has a copy of, the cache controller updates its own copy of the snooped memory location with the new data.  Write-invalidate: When a write operation is observed to a location that a cache has a copy of, the cache controller invalidates its own copy of the snooped memory location, which forces a read from main memory of the new value on its next access.Write-invalidate 在一些情况下的优势是很明显的，例如突发大量对单个单元写请求的情况下，它比 write-update 有更好的效果，其每次对内存单元的更新不会引起其他 cache 的更新，因为这个时候其他单元不一定总有 read 请求，write 之后只会对这个内存对应的 cache（其 copy）做一个 invalid 标记，并且在做标记之前如果发现已经是 invalid 状态就不用更新了，因此在没有 read 的情况下只需要发送一次 invalidation 广播，下次其他单元需要访问相应内存时检测到自己 cache 上的 invalid 标记就直接去主存里取数据并更新自己的 cache。此外还有一种情况，例如 writes to different words of a block，write-update 在每一个 word 写操作都会发送一次更新请求，而 write-invalidate 由于同理也只会发送一次 invalidation 广播。但是对于 producer-consumer 模型而言，producer 的每次更新都要等待一个 consumer 来消费，这就是与之前两种情况不同的一点。这种情况下如果每次还是采用广播 invalidate 消息的方法，下一次某个 consumer 消费的时候检测到自己 cache invalid 状态后便还需要去访问主存，这是完全多余的了，因为我们完全可以在生成好之后直接更新 consumer 的 cache，这样只需要一次写会主存的操作而不是两次。因此这时 write-update 优于 write-invalidate。总结一下，对于大量连续的写请求来说，write-invalidate 更好，对于 producer-consumer 这种供需平衡的模型来说 write-update 更优。关于 cache coherency 这方面还有许多复杂并且值得探讨的问题，但由于它们太过学术我没有去深究。References  https://www3.nd.edu/~mniemier/teaching/2010_B_Fall/lectures/lec_27_slides.pdf.  https://www.cs.utah.edu/~retrac/papers/hpca07.pdf."

    } ,
  
    {

      "title"    : "D^3CTF2019 Ancient Game V2, thoughts &amp; solutions",
      "url"      : "/2020/02/20/ancient-game-v2",
      "category" : "",
      "tags"     : "CTF, Reverse Engineering, D^3CTF2019, OISC",
      "date"     : "2020-02-20 00:00:00 +0800",
      "description" : "",
      "content"  : "IntroI designed the RE challenge Ancient Game V2 in D^3CTF2019. This post is about some related stuff along with the chal’s solution.ChallengeThis challenge uses a virtual architecture similar to OISC to implement a classic Sudoku verification. There are 4 types of instructions, and all logical operations are implemented through NAND gates. A branch control and two I / O interrupts are also issued.Operations like XOR / AND / OR are all implemented by combinations of NAND gates, for example:xor x,y =gt;xor_tmp[0] = y NAND yxor_tmp[1] = x NAND xor_tmp[0]xor_tmp[2] = x NAND xxor_tmp[3] = y NAND xor_tmp[2]x = xor_tmp[1] NAND xor_tmp[3]Which is based on the fact that:Q = A XOR B = [ B NAND ( A NAND A ) ] NAND [ A NAND ( B NAND B ) ]An excerpt of the Sudoku Verifier code in my self-defined assembly:welcome = mkstr(**************************#92;hhhhhhhhhhhhn**  Welcome To D^3CTF   **#92;hhhhhhhhhhhhn**   Ancient Game V2    **#92;hhhhhhhhhhhhn**************************#92;hhhhhhhhhhhhn#92;hhhhhhhhhhhhnInput Flag:)wrong = mkstr(#92;hhhhhhhhhhhhnSorry, please try again.#92;hhhhhhhhhhhhn)correct = mkstr(#92;hhhhhhhhhhhhnCorrect.#92;hhhhhhhhhhhhn)flag = new(50)// distract = new(1000)grid = new(81)// initialize the puzzleset(grid[0],9)set(grid[5],8)set(grid[9],1)set(grid[10],3)set(grid[14],9)set(grid[16],7)...set(grid[71],6)set(grid[75],9)set(grid[80],1)__code_start__// print the welcome messageprint(welcome)// get inputinput(flag[0])input(flag[1])input(flag[2])input(flag[3])input(flag[4])input(flag[5])...input(flag[46])input(flag[47])input(flag[48])input(flag[49])// transfer chars in the flag into the gridslong_transfer(flag[0],grid[1])long_transfer(flag[1],grid[2])...long_transfer(flag[47],grid[77])long_transfer(flag[48],grid[78])long_transfer(flag[49],grid[79])// xor with xor_table, which is introduced //   for generating different flags to different teamsgrid[1] = grid[1] ^ xor_table[0]grid[2] = grid[2] ^ xor_table[1]grid[3] = grid[3] ^ xor_table[2]grid[4] = grid[4] ^ xor_table[3]grid[6] = grid[6] ^ xor_table[4]grid[7] = grid[7] ^ xor_table[5]...grid[77] = grid[77] ^ xor_table[47]grid[78] = grid[78] ^ xor_table[48]grid[79] = grid[79] ^ xor_table[49]// verify the sudoku game// rowsjmp _label_wrong if grid[4] == grid[5]jmp _label_wrong if grid[4] == grid[6]jmp _label_wrong if grid[4] == grid[7]...jmp _label_wrong if grid[3] == grid[7]jmp _label_wrong if grid[3] == grid[8]// columnsjmp _label_wrong if grid[0] == grid[9]jmp _label_wrong if grid[0] == grid[18]jmp _label_wrong if grid[0] == grid[27]...jmp _label_wrong if grid[62] == grid[80]jmp _label_wrong if grid[71] == grid[80]// subgridsjmp _label_wrong if grid[0] == grid[1]jmp _label_wrong if grid[0] == grid[2]jmp _label_wrong if grid[0] == grid[9]jmp _label_wrong if grid[0] == grid[10]...jmp _label_wrong if grid[78] == grid[79]jmp _label_wrong if grid[78] == grid[80]jmp _label_wrong if grid[79] == grid[80]// check rangejmp _label_wrong if outofnumbers(grid[1])jmp _label_wrong if outofnumbers(grid[2])jmp _label_wrong if outofnumbers(grid[3])jmp _label_wrong if outofnumbers(grid[4])...jmp _label_wrong if outofnumbers(grid[76])jmp _label_wrong if outofnumbers(grid[77])jmp _label_wrong if outofnumbers(grid[78])jmp _label_wrong if outofnumbers(grid[79])_label_correct:print(correct)return_label_wrong:print(wrong)returnI wrote an assembler for this assembly, which was used to generate the final challenge that the players got. The assembler wasn’t open-sourced since it’s ugly.During the competition, due to the negligence of myself, the implementation of the outofnumbers (var) function was incorrectly written as return var in range (10), resulting in multiple solutions. Since the target Sudoku should only be filled with 1 ~ 9, the correct implementation should be return var in range (1, 10). This was my fault, and I had to update the challenge with a fixed one during the competition.Sudoku MapSolutionTo solve this challenge, there is no need to simplify all the logical operations. Since there is no complicated loop in the chal’s actual control flow, we can find conditions that prevent the control flow from jumping to the part which outputs “Sorry” through simple control flow tracing and symbolic analysis. Finally, we can use an SMT solver to solve the constraints that we get through the previous analysis(That’s how ThinerDAS solved this challenge).Flag: d3ctfg5lk9t28zz47y3l6m2kosbajd2vk9e2dwghxgfktcki  Referenceable solution script: sol.py by ByaiduThe source code of this challenge(not fully open-sourced) and a duplicate of this post are uploaded to GitHub, check them out at: https://github.com/yype/D3CTF_Rev/tree/master/AncientGameV2.More..I’ve always found OISC quite interesting to me. This challenge was just a demo of one of my ideas, maybe I will do some extra work related to OISC in the upcoming future."

    } 
  
]