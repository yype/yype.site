[
  
    {

      "title"    : "Solutions to Understanding Cryptography Problems - Chapter 2",
      "url"      : "/2021/01/26/answers-to-understanding-cryptography-problems-chapter2",
      "category" : "",
      "tags"     : "Crypto, Understanding Cryptography",
      "date"     : "2021-01-26 00:00:00 +0800",
      "description" : "",
      "content"  : "  Intro  Problems          2.1      2.2      2.3      2.4      2.5      2.6      2.7      2.8      2.9      2.10      IntroMy solutions to the practice problems in “Understanding Cryptography: A Textbook for Students and Practitioners - Chapter 2”.The solution scripts to some of the problems have been uploaded to GitHub, you can check them out at: https://github.com/yype/UnderstandingCrypto.Problems2.1(1) The key could look like a stream of letters from A~Z, which represent keys between 0~25.#92;hhhhhhhhhhhh[y_i=e_k_i(x_i)=x_i+k_i#92;hhhhhhhhhhhhbmod26#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhx_i=d_k_i(y_i)=y_i-k_i#92;hhhhhhhhhhhhbmod26#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh](2) I found this problem strange at first, and later, according to the Internet, I found that the key provided in the book is wrong. The correct key should be rsidpy dkawoy.Solution script:enc = &#39;bsaspp kkuosp&#39;key = &#39;rsidpy dkawoy&#39;  # the key in the book is wrongdec = &#39;&#39;for i in range(len(enc)):    if enc[i] != &#39; &#39;:        e, k = ord(enc[i])-ord(&#39;a&#39;), ord(key[i])-ord(&#39;a&#39;)        dec += chr(((e-k)  26)+ord(&#39;a&#39;))    else:        dec += &#39; &#39;print(dec)Output:kaspar hauser(3) According to this, it seems that Hauser died of a fatal stab wound on 17 December 1833.2.2(1) Life cycle of the key: Every single bit in the key should never be reused.(2) Storage of the key during the life cycle: The key must be stored at both the sending and receiving end.(3) Storage of the key after the life cycle: They must be destroyed since all former encrypted data will become vulunerable if these keys are leaked in the future.(4) Key distribution: The safest way, in my point of view, is to make only 2 copies of the key in the world, and to distribute the keys physically(without being intercepted by any 3rd parties).(5) Generation of the key: A TRNG should be used. Or else it will be the same as using a normal stream cipher along with a PRNG, and just distributing the key of the PRNG.2.3When 128 bits of the plaintext(x_0~x_127) and their corresponding cipher bits(y_0~y_127) are known to an attacker, he/she/it can easily calculate the key bits(k_0~k_127) used in the encryption process:#92;hhhhhhhhhhhh[k_i=x_i#92;hhhhhhhhhhhhoplus y_i,i=0,1,...,127#92;hhhhhhhhhhhh]2.4The attacker will have no idea which key should be correct, so any brute-force attack is meaningless. Each key guessed can be used to decrypt the ciphertext, generating a plaintext(plaindata). There is no way the attacker can know which key is right and if the plaintext decrypted is the original one.2.5(1)#92;hhhhhhhhhhhh[(c_2=1,c_1=0,c_0=1)#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtext#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhbeginarray|c|c c c|#92;hhhhhhhhhhhhtextClk amp; FF_2 amp; FF_1 amp; FF_0=s_i #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh0 amp; 1 amp; 0 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1 amp; 1 amp; 1 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh2 amp; 1 amp; 1 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh3 amp; 0 amp; 1 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh4 amp; 1 amp; 0 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh5 amp; 0 amp; 1 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh6 amp; 0 amp; 0 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh7 amp; 1 amp; 0 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhendarray#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh]So the sequence is (0011101)*.(2)#92;hhhhhhhhhhhh[(c_2=1,c_1=0,c_0=1)#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtext#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhbeginarray|c|c c c|#92;hhhhhhhhhhhhtextClk amp; FF_2 amp; FF_1 amp; FF_0=s_i #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh0 amp; 0 amp; 1 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1 amp; 1 amp; 0 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh2 amp; 0 amp; 1 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh3 amp; 0 amp; 0 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh4 amp; 1 amp; 0 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh5 amp; 1 amp; 1 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh6 amp; 1 amp; 1 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh7 amp; 0 amp; 1 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhendarray#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh]So the sequence is (1101001)*.(3) a) Their periods are the same. b) S2 can be viewed as ROL(S1, 3), where S1/S2 represent the repetends of the first and second sequence.2.6One possible attack: I will need to know 25 bytes(letters), which is 200(bits) / 8(bits/byte), of the ciphertext and their corresponding plaintext. Then I will be able to calculate 200 bits of the key sequence used(k_i=#92;hhhhhhhhhhhhtextplainbit_i#92;hhhhhhhhhhhhoplus#92;hhhhhhhhhhhhtextcipherbit_i).After that, all left to do is to determine the actual keysize. We can simply run several brute-force decryptions, starting from the first plaintext bit we know, using the first k bits of the 200 key bits calculated, where k=150,151,…,200.It should be noted that if the keysize used is not correct, there is a great chance that the data decrypted is not readable(printable) ASCII text. As a result, once we successfully decrypt the ciphertext and get a readable plaintext after the 25th byte, we know what the actual keysize is.2.7The chosen LFSR’s polynomial is (0,1,3,4,8). I wrote a simple script to help me with the calculation, and the resulting first two output bytes can be viewed as a little endian number 0x90ff.chapt2gt; py .#92;hhhhhhhhhhhhp2.7.py0x90ff2.8(1) Draw the corresponding LFSR for each of the three polynomials.I don’t want to draw them :P(2) I wrote a script to calculate all the possible initial values and their corresponding sequence lengh, it outputs as follows:chapt2gt; py .#92;hhhhhhhhhhhhp2.8.pyPolynomial: (0, 1, 4)init            len(seq)1               152               153               154               155               156               157               158               159               1510              1511              1512              1513              1514              1515              15Polynomial: (0, 2, 4)init            len(seq)1               62               63               64               65               66               37               68               69               610              611              312              613              314              615              6Polynomial: (0, 1, 2, 3, 4)init            len(seq)1               52               53               54               55               56               57               58               59               510              511              512              513              514              515              5We can see that, the first polynomial x^4+x+1 can generate a maximum-length(2^4-1=15) sequence, so it is a primitive polynomial. The second polynomial x^4+x^2+1 does not generate a maximum-length sequence and its sequence length depends on its initial value, so it is an irreducible polynomial. The third polynomial x^4+x^3+x^2+x+1 does not generate a maximum-length sequence, but its sequence length stays the same despite the changing initial value, so it is a reducible polynomial.2.9(1) 256#92;hhhhhhhhhhhhtimes2=512#92;hhhhhhhhhhhhtext(bits).(2) Let the known plaintext bits be given by x_0,x_1,…,x_511 and the corresponding ciphertext bits by y_0,y_1,…,y_511. With these 512 pairs of plaintext and ciphertext bits, we can reconstruct the first 512 key stream bits:#92;hhhhhhhhhhhh[s_i=x_i#92;hhhhhhhhhhhhoplus y_i,i=0,1,...,511#92;hhhhhhhhhhhh]Our goal is to find the key bits given by the feedback coefficients p_i. The relationship between the unknown key bits p_i and the key stream bits s_i can be described as follows:#92;hhhhhhhhhhhh[s_i+256=#92;hhhhhhhhhhhhsum_j=0^255p_j#92;hhhhhhhhhhhhcdot s_i+j, i=0,1,...,255#92;hhhhhhhhhhhh]This actually represents 256 linearly independent formulae, which contain 256 unknown variables p_0,p_1,…,p_255. This system can be easily solved using Gaussian elimination, matrix inversion or any other algorithm for solving systems of linear equations.(3.a) The key is p_0,p_1,…,p_255.(3.b) If we use the initial contents of the LFSR as the key, the attacker can get the key almost without performing any attack since the first 256 bits of the key stream bits are exactly the same as the initial content bits. If we use the initial contents of the LFSR as part of the key, the part that takes actual effect will be just the initial content, so any other bits in the key will be useless, then the situation becomes no different as just using the initial contents as the key.2.10Plaintext bits:  `1001 0010 0110 1101 1001 0010 0110`Ciphertext bits: `1011 1100 0011 0001 0010 1011 0001` So we can get the key stream bits: 0010 1110 0101 1100 1011 1001 0111.We can clearly observe its repetend: 0010111. Let’s suppose it’s generated by a primitive polynomial, then the degree should be m=#92;hhhhhhhhhhhhlog_2(7+1)=3. Next we test if there are indeed 2^m-1=7 sequence states. As for the key stream bits, the states are as follows:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbeginarray|c|c c c|#92;hhhhhhhhhhhhtextClk amp; FF_2 amp; FF_1 amp; FF_0=s_i #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh0 amp; 1 amp; 0 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1 amp; 0 amp; 1 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh2 amp; 1 amp; 0 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh3 amp; 1 amp; 1 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh4 amp; 1 amp; 1 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh5 amp; 0 amp; 1 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh6 amp; 0 amp; 0 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh7 amp; 1 amp; 0 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhendarray#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh]We can see that there are 7 sequence states(the sequence length is 7). Therefore, it’s possible, that the LFSR could be using a primitive polynomial of degree 3.  Note that we can never know if the key stream contains a larger repetend. Using the given information, we can only be sure that an LFSR using a primitive polynomial of degree 3 could be possible. There is a possibility that an LFSR using a polynomial of a larger degree is actually used. Specifically for this problem, I’ll just assume the degree is 3.(1) What is the degree m of the key stream generator?It’s 3.(2) What is the initialization vector?It’s 100.(3) Determine the feedback coefficients of the LFSR.To break the cipher we only need to use 2m=6 key stream bits, let’s grab the first 6 bits of the key stream. Let the coefficients be p_0,p_1,p_2, then we have:#92;hhhhhhhhhhhh[s_3=s_0p_0+s_1p_1+s_2p_2#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhs_4=s_1p_0+s_2p_1+s_3p_2#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhs_5=s_2p_0+s_3p_1+s_4p_2#92;hhhhhhhhhhhh]which can be denoted as:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbeginbmatrix0 amp; 0 amp; 1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh0 amp; 1 amp; 0#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1 amp; 0 amp; 1#92;hhhhhhhhhhhhendbmatrix#92;hhhhhhhhhhhhbeginbmatrixp_0#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh p_1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhp_2#92;hhhhhhhhhhhhendbmatrix=#92;hhhhhhhhhhhhbeginbmatrix0#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1#92;hhhhhhhhhhhhendbmatrix#92;hhhhhhhhhhhh]We can calculate P by:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbeginalignedP=#92;hhhhhhhhhhhhbeginbmatrixp_0#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh p_1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhp_2#92;hhhhhhhhhhhhendbmatrixamp;=#92;hhhhhhhhhhhhbeginbmatrix0 amp; 0 amp; 1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh0 amp; 1 amp; 0#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1 amp; 0 amp; 1#92;hhhhhhhhhhhhendbmatrix^-1#92;hhhhhhhhhhhhbeginbmatrix0#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1#92;hhhhhhhhhhhhendbmatrix#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=#92;hhhhhhhhhhhhbeginbmatrix-1amp;0amp;1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh0amp;1amp;0#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1amp;0amp;0#92;hhhhhhhhhhhhendbmatrix#92;hhhhhhhhhhhhbeginbmatrix0#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1#92;hhhhhhhhhhhhendbmatrix#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=#92;hhhhhhhhhhhhbeginbmatrix1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh0#92;hhhhhhhhhhhhendbmatrix#92;hhhhhhhhhhhhendaligned#92;hhhhhhhhhhhh]So the coefficients are: p_0=1,p_1=1,p_2=0, the polynomial used is x^3+x+1.(4.a)I don’t want to draw the circuit diagram :P(4.b)I wrote a script to help with the key stream generation and the coefficient verification, see the corresponding solution script for more detail."

    } ,
  
    {

      "title"    : "Solutions to Understanding Cryptography Problems - Chapter 1",
      "url"      : "/2021/01/25/answers-to-understanding-cryptography-problems-chapter1",
      "category" : "",
      "tags"     : "Crypto, Understanding Cryptography",
      "date"     : "2021-01-25 00:00:00 +0800",
      "description" : "",
      "content"  : "  Intro  Problems          1.1      1.2      1.3      1.4      1.5      1.6      1.7      1.8      1.9      1.10      1.11      1.12      1.13      1.14      IntroMy solutions to the practice problems in “Understanding Cryptography: A Textbook for Students and Practitioners - Chapter 1”.The solution scripts to some of the problems have been uploaded to GitHub, you can check them out at: https://github.com/yype/UnderstandingCrypto.Problems1.1(1) Compute the relative frequency of all letters in the ciphertext.[(&#39;r&#39;, 0.13003095975232198), (&#39;b&#39;, 0.10526315789473684), (&#39;m&#39;, 0.09597523219814241), (&#39;k&#39;, 0.07585139318885449), (&#39;j&#39;, 0.07430340557275542), (&#39;w&#39;, 0.07275541795665634), (&#39;i&#39;, 0.06346749226006192), (&#39;p&#39;, 0.04643962848297214), (&#39;u&#39;, 0.03715170278637771), (&#39;d&#39;, 0.03560371517027864), (&#39;h&#39;, 0.03560371517027864), (&#39;v&#39;, 0.034055727554179564), (&#39;x&#39;, 0.030959752321981424), (&#39;y&#39;, 0.029411764705882353), (&#39;n&#39;, 0.02631578947368421), (&#39;s&#39;, 0.02631578947368421), (&#39;t&#39;, 0.020123839009287926), (&#39;l&#39;, 0.01238390092879257), (&#39;q&#39;, 0.010835913312693499), (&#39;o&#39;, 0.010835913312693499), (&#39;e&#39;, 0.007739938080495356), (&#39;a&#39;, 0.007739938080495356), (&#39;c&#39;, 0.007739938080495356), (&#39;f&#39;, 0.0015479876160990713), (&#39;g&#39;, 0.0015479876160990713)](2) Decrypt the ciphertext.because the practice of the basic movements of kata isthe focus and mastery of self is the essence ofmatsubayashi ryu karate do i shall try to elucidate themovements of the kata according to my interpretationbased on forty years of studyit is not an easy task to explain each movement and itssignificance and some must remain unexplained to give acomplete explanation one would have to be qualified andinspired to such an extent that he could reach the stateof enlightened mind capable of recognizing soundlesssound and shapeless shape i do not deem myself the finalauthority but my experience with kata has left no doubtthat the following is the proper application andinterpretation i offer my theories in the hope that theessence of okinawan karate will remain intactThe decryption process involves a little bit of manual tweaking, as can be seen in the solution script output:Freqs in the text -gt; freqs of letters in the alphabet(&#39;r&#39;, 0.13003095975232198) -gt; (&#39;e&#39;, 0.127)(&#39;b&#39;, 0.10526315789473684) -gt; (&#39;t&#39;, 0.0906)(&#39;m&#39;, 0.09597523219814241) -gt; (&#39;a&#39;, 0.0817)(&#39;k&#39;, 0.07585139318885449) -gt; (&#39;o&#39;, 0.0751)(&#39;j&#39;, 0.07430340557275542) -gt; (&#39;i&#39;, 0.0697)(&#39;w&#39;, 0.07275541795665634) -gt; (&#39;n&#39;, 0.0675)(&#39;i&#39;, 0.06346749226006192) -gt; (&#39;s&#39;, 0.0633)(&#39;p&#39;, 0.04643962848297214) -gt; (&#39;h&#39;, 0.0609)(&#39;u&#39;, 0.03715170278637771) -gt; (&#39;r&#39;, 0.0599)(&#39;d&#39;, 0.03560371517027864) -gt; (&#39;d&#39;, 0.0425)(&#39;h&#39;, 0.03560371517027864) -gt; (&#39;l&#39;, 0.0403)(&#39;v&#39;, 0.034055727554179564) -gt; (&#39;c&#39;, 0.0278)(&#39;x&#39;, 0.030959752321981424) -gt; (&#39;u&#39;, 0.0276)(&#39;y&#39;, 0.029411764705882353) -gt; (&#39;m&#39;, 0.02414)(&#39;n&#39;, 0.02631578947368421) -gt; (&#39;w&#39;, 0.0236)(&#39;s&#39;, 0.02631578947368421) -gt; (&#39;f&#39;, 0.0223)(&#39;t&#39;, 0.020123839009287926) -gt; (&#39;g&#39;, 0.0202)(&#39;l&#39;, 0.01238390092879257) -gt; (&#39;y&#39;, 0.0197)(&#39;q&#39;, 0.010835913312693499) -gt; (&#39;p&#39;, 0.0193)(&#39;o&#39;, 0.010835913312693499) -gt; (&#39;b&#39;, 0.015)(&#39;e&#39;, 0.007739938080495356) -gt; (&#39;v&#39;, 0.0098)(&#39;a&#39;, 0.007739938080495356) -gt; (&#39;k&#39;, 0.0077)(&#39;c&#39;, 0.007739938080495356) -gt; (&#39;j&#39;, 0.0015)(&#39;f&#39;, 0.0015479876160990713) -gt; (&#39;x&#39;, 0.0015)(&#39;g&#39;, 0.0015479876160990713) -gt; (&#39;q&#39;, 0.001)Trying to decipher:yecawse the fractnce iu the yasnc mivemeots iu pata nsthe uicws aod masterg iu selu ns the esseoce iumatswyagashn rgw parate di n shall trg ti elwcndate themivemeots iu the pata accirdnob ti mg noterfretatnioyased io uirtg gears iu stwdgnt ns oit ao easg tasp ti ekflano each mivemeot aod ntssnbonuncaoce aod sime mwst remano woekflanoed ti bnve acimflete ekflaoatnio ioe jiwld have ti ye xwalnuned aodnosfnred ti swch ao ekteot that he ciwld reach the stateiu eolnbhteoed mnod cafayle iu recibonqnob siwodlesssiwod aod shafeless shafe n di oit deem mgselu the unoalawthirntg ywt mg ekferneoce jnth pata has leut oi diwytthat the uillijnob ns the frifer afflncatnio aodnoterfretatnio n iuuer mg theirnes no the hife that theesseoce iu ipnoajao parate jnll remano notactDoing corrections manually:l -gt; y ==gt; l -gt; b        Conflit: l -gt; b        Conflit: o -gt; bq -gt; p ==gt; q -gt; k        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; kt -gt; g ==gt; t -gt; y        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; kn -gt; w ==gt; n -gt; u        Conflit: x -gt; u        Conflit: n -gt; u        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; kw -gt; n ==gt; w -gt; i        Conflit: j -gt; i        Conflit: w -gt; i        Conflit: x -gt; u        Conflit: n -gt; u        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; kj -gt; i ==gt; j -gt; o        Conflit: k -gt; o        Conflit: j -gt; o        Conflit: x -gt; u        Conflit: n -gt; u        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; kk -gt; o ==gt; k -gt; n        Conflit: x -gt; u        Conflit: n -gt; u        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; ks -gt; f ==gt; s -gt; p        Conflit: x -gt; u        Conflit: n -gt; u        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; kc -gt; j ==gt; c -gt; w        Conflit: x -gt; u        Conflit: n -gt; u        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; kx -gt; u ==gt; x -gt; f        Conflit: l -gt; b        Conflit: q -gt; k        Conflit: o -gt; b        Conflit: a -gt; ka -gt; k ==gt; a -gt; x        Conflit: l -gt; b        Conflit: o -gt; b        Conflit: a -gt; x        Conflit: f -gt; xo -gt; b ==gt; o -gt; g        Conflit: a -gt; x        Conflit: f -gt; xg -gt; q ==gt; g -gt; z        Conflit: a -gt; x        Conflit: f -gt; xf -gt; x ==gt; f -gt; q        Check okCorresponding words:[(&#39;lrvmnir&#39;, &#39;because&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;sumvbwvr&#39;, &#39;practice&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;lmiwv&#39;, &#39;basic&#39;), (&#39;yjeryrkbi&#39;, &#39;movements&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;qmbm&#39;, &#39;kata&#39;), (&#39;wi&#39;, &#39;is&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;xjvni&#39;, &#39;focus&#39;), (&#39;mkd&#39;, &#39;and&#39;), (&#39;ymibrut&#39;, &#39;mastery&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;irhx&#39;, &#39;self&#39;), (&#39;wi&#39;, &#39;is&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;riirkvr&#39;, &#39;essence&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;ymbinlmtmipw&#39;, &#39;matsubayashi&#39;), (&#39;utn&#39;, &#39;ryu&#39;), (&#39;qmumbr&#39;, &#39;karate&#39;), (&#39;dj&#39;, &#39;do&#39;), (&#39;w&#39;, &#39;i&#39;), (&#39;ipmhh&#39;, &#39;shall&#39;), (&#39;but&#39;, &#39;try&#39;), (&#39;bj&#39;, &#39;to&#39;), (&#39;rhnvwdmbr&#39;, &#39;elucidate&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;yjeryrkbi&#39;, &#39;movements&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;qmbm&#39;, &#39;kata&#39;), (&#39;mvvjudwko&#39;, &#39;according&#39;), (&#39;bj&#39;, &#39;to&#39;), (&#39;yt&#39;, &#39;my&#39;), (&#39;wkbrusurbmbwjk&#39;, &#39;interpretation&#39;), (&#39;lmird&#39;, &#39;based&#39;), (&#39;jk&#39;, &#39;on&#39;), (&#39;xjubt&#39;, &#39;forty&#39;), (&#39;trmui&#39;, &#39;years&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;ibndt&#39;, &#39;study&#39;), (&#39;wb&#39;, &#39;it&#39;), (&#39;wi&#39;, &#39;is&#39;), (&#39;kjb&#39;, &#39;not&#39;), (&#39;mk&#39;, &#39;an&#39;), (&#39;rmit&#39;, &#39;easy&#39;), (&#39;bmiq&#39;, &#39;task&#39;), (&#39;bj&#39;, &#39;to&#39;), (&#39;rashmwk&#39;, &#39;explain&#39;), (&#39;rmvp&#39;, &#39;each&#39;), (&#39;yjeryrkb&#39;, &#39;movement&#39;), (&#39;mkd&#39;, &#39;and&#39;), (&#39;wbi&#39;, &#39;its&#39;), (&#39;iwokwxwvmkvr&#39;, &#39;significance&#39;), (&#39;mkd&#39;, &#39;and&#39;), (&#39;ijyr&#39;, &#39;some&#39;), (&#39;ynib&#39;, &#39;must&#39;), (&#39;urymwk&#39;, &#39;remain&#39;), (&#39;nkrashmwkrd&#39;, &#39;unexplained&#39;), (&#39;bj&#39;, &#39;to&#39;), (&#39;ower&#39;, &#39;give&#39;), (&#39;m&#39;, &#39;a&#39;), (&#39;vjyshrbr&#39;, &#39;complete&#39;), (&#39;rashmkmbwjk&#39;, &#39;explanation&#39;), (&#39;jkr&#39;, &#39;one&#39;), (&#39;cjnhd&#39;, &#39;would&#39;), (&#39;pmer&#39;, &#39;have&#39;), (&#39;bj&#39;, &#39;to&#39;), (&#39;lr&#39;, &#39;be&#39;), (&#39;fnmhwxwrd&#39;, &#39;qualified&#39;), (&#39;mkd&#39;, &#39;and&#39;), (&#39;wkiswurd&#39;, &#39;inspired&#39;), (&#39;bj&#39;, &#39;to&#39;), (&#39;invp&#39;, &#39;such&#39;), (&#39;mk&#39;, &#39;an&#39;), (&#39;rabrkb&#39;, &#39;extent&#39;), (&#39;bpmb&#39;, &#39;that&#39;), (&#39;pr&#39;, &#39;he&#39;), (&#39;vjnhd&#39;, &#39;could&#39;), (&#39;urmvp&#39;, &#39;reach&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;ibmbr&#39;, &#39;state&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;rkhwopbrkrd&#39;, &#39;enlightened&#39;), (&#39;ywkd&#39;, &#39;mind&#39;), (&#39;vmsmlhr&#39;, &#39;capable&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;urvjokwgwko&#39;, &#39;recognizing&#39;), (&#39;ijnkdhrii&#39;, &#39;soundless&#39;), (&#39;ijnkd&#39;, &#39;sound&#39;), (&#39;mkd&#39;, &#39;and&#39;), (&#39;ipmsrhrii&#39;, &#39;shapeless&#39;), (&#39;ipmsr&#39;, &#39;shape&#39;), (&#39;w&#39;, &#39;i&#39;), (&#39;dj&#39;, &#39;do&#39;), (&#39;kjb&#39;, &#39;not&#39;), (&#39;drry&#39;, &#39;deem&#39;), (&#39;ytirhx&#39;, &#39;myself&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;xwkmh&#39;, &#39;final&#39;), (&#39;mnbpjuwbt&#39;, &#39;authority&#39;), (&#39;lnb&#39;, &#39;but&#39;), (&#39;yt&#39;, &#39;my&#39;), (&#39;rasruwrkvr&#39;, &#39;experience&#39;), (&#39;cwbp&#39;, &#39;with&#39;), (&#39;qmbm&#39;, &#39;kata&#39;), (&#39;pmi&#39;, &#39;has&#39;), (&#39;hrxb&#39;, &#39;left&#39;), (&#39;kj&#39;, &#39;no&#39;), (&#39;djnlb&#39;, &#39;doubt&#39;), (&#39;bpmb&#39;, &#39;that&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;xjhhjcwko&#39;, &#39;following&#39;), (&#39;wi&#39;, &#39;is&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;sujsru&#39;, &#39;proper&#39;), (&#39;msshwvmbwjk&#39;, &#39;application&#39;), (&#39;mkd&#39;, &#39;and&#39;), (&#39;wkbrusurbmbwjk&#39;, &#39;interpretation&#39;), (&#39;w&#39;, &#39;i&#39;), (&#39;jxxru&#39;, &#39;offer&#39;), (&#39;yt&#39;, &#39;my&#39;), (&#39;bprjuwri&#39;, &#39;theories&#39;), (&#39;wk&#39;, &#39;in&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;pjsr&#39;, &#39;hope&#39;), (&#39;bpmb&#39;, &#39;that&#39;), (&#39;bpr&#39;, &#39;the&#39;), (&#39;riirkvr&#39;, &#39;essence&#39;), (&#39;jx&#39;, &#39;of&#39;), (&#39;jqwkmcmk&#39;, &#39;okinawan&#39;), (&#39;qmumbr&#39;, &#39;karate&#39;), (&#39;cwhh&#39;, &#39;will&#39;), (&#39;urymwk&#39;, &#39;remain&#39;), (&#39;wkbmvb&#39;, &#39;intact&#39;)]Deciphered text:because the practice of the basic movements of kata isthe focus and mastery of self is the essence ofmatsubayashi ryu karate do i shall try to elucidate themovements of the kata according to my interpretationbased on forty years of studyit is not an easy task to explain each movement and itssignificance and some must remain unexplained to give acomplete explanation one would have to be qualified andinspired to such an extent that he could reach the stateof enlightened mind capable of recognizing soundlesssound and shapeless shape i do not deem myself the finalauthority but my experience with kata has left no doubtthat the following is the proper application andinterpretation i offer my theories in the hope that theessence of okinawan karate will remain intactKey maps:rbmkjwipudhvxynstlqoeacfgetanoishrdlcfmupybkgvxwqzr 0.13003095975232198 -gt; e 0.127b 0.10526315789473684 -gt; t 0.0906m 0.09597523219814241 -gt; a 0.0817k 0.07585139318885449 -gt; n 0.0675j 0.07430340557275542 -gt; o 0.0751w 0.07275541795665634 -gt; i 0.0697i 0.06346749226006192 -gt; s 0.0633p 0.04643962848297214 -gt; h 0.0609u 0.03715170278637771 -gt; r 0.0599d 0.03560371517027864 -gt; d 0.0425h 0.03560371517027864 -gt; l 0.0403v 0.034055727554179564 -gt; c 0.0278x 0.030959752321981424 -gt; f 0.0223y 0.029411764705882353 -gt; m 0.02414n 0.02631578947368421 -gt; u 0.0276s 0.02631578947368421 -gt; p 0.0193t 0.020123839009287926 -gt; y 0.0197l 0.01238390092879257 -gt; b 0.015q 0.010835913312693499 -gt; k 0.0077o 0.010835913312693499 -gt; g 0.0202e 0.007739938080495356 -gt; v 0.0098a 0.007739938080495356 -gt; x 0.0015c 0.007739938080495356 -gt; w 0.0236f 0.0015479876160990713 -gt; q 0.001g 0.0015479876160990713 -gt; z 0.0007(3) It’s from “Essence of Okinawan Karate-Do” by Shoshin Nagamine.1.2Decipher the following ciphertext encoded with a shift cipher:xultpaajcxitltlxaarpjhtiwtgxktghidhipxciwtvgtpilpitghlxiwiwtxgqadds.(1) First we calculate the frequency of each letter in the ciphertext:[(&#39;t&#39;, 10), (&#39;i&#39;, 9), (&#39;x&#39;, 7), (&#39;l&#39;, 5), (&#39;p&#39;, 5), (&#39;a&#39;, 5), (&#39;g&#39;, 5), (&#39;h&#39;, 4), (&#39;w&#39;, 4), (&#39;d&#39;, 3), (&#39;j&#39;, 2), (&#39;c&#39;, 2), (&#39;u&#39;, 1), (&#39;r&#39;, 1), (&#39;k&#39;, 1), (&#39;v&#39;, 1), (&#39;q&#39;, 1), (&#39;s&#39;, 1)]As can be seen, letter t appears mostly in the ciphertext, which corresponds to the mostly appearing letter e in the alphabet. So now we know e has probably been transformed to t, and the shift number is ord(&#39;t&#39;) - ord(&#39;e&#39;) which is 15. After trying 15 as the shift number, I successfully deciphered the ciphertext, so I identified only one letter.(2) Using 15 as the shift number:ifweallunitewewillcausetheriverstostainthegreatwaterswiththeirblood.After manually inserting some spaces between words:if we all unite we will cause the rivers to stain the great waters with their blood.(3) It’s from Tecumseh’s speech to the Osages.1.3(1) ASICs that can run in parallel:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhfrac1000000(50#92;hhhhhhhhhhhhtimes2)=10000#92;hhhhhhhhhhhh]Seconds it takes to do an average key search:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhfrac2^128-1(10000#92;hhhhhhhhhhhhtimes5#92;hhhhhhhhhhhhtimes10^8)=3.40282#92;hhhhhhhhhhhhtimes 10^25 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh3.40282#92;hhhhhhhhhhhhtimes 10^25 secs #92;hhhhhhhhhhhhapprox 1.07903#92;hhhhhhhhhhhhtimes 10^18 years#92;hhhhhhhhhhhh]This is much longer than the age of the universe (#92;hhhhhhhhhhhhapprox10^8 times).(2) Represent the number of Moore’s Law iterations as x, we can get the following equation:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhfrac2^128-1#92;hhhhhhhhhhhhfrac1000000(50#92;hhhhhhhhhhhhtimes2)#92;hhhhhhhhhhhhtimes(5#92;hhhhhhhhhhhhtimes10^8)#92;hhhhhhhhhhhhtimes2^x=24#92;hhhhhhhhhhhhtimes60#92;hhhhhhhhhhhhtimes60#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhx=68.4162#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhfrac1812#92;hhhhhhhhhhhhtimes68.4162#92;hhhhhhhhhhhhapprox102.624#92;hhhhhhhhhhhh (years)#92;hhhhhhhhhhhh]So it’ll take approximately 103 years.1.4(1) Size of the key space that can be constructed be the specified passwords:#92;hhhhhhhhhhhh[128^8=2^56#92;hhhhhhhhhhhh](2) The corresponding key length in bits: #92;hhhhhhhhhhhhlog_22^56=56.(3) The corresponding key length in bits when users use only the 26 lowercase letters from the alphabet:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhlog_226^8#92;hhhhhhhhhhhhapprox37.6035#92;hhhhhhhhhhhhapprox38#92;hhhhhhhhhhhh](4) a. 7-bit characters:#92;hhhhhhhhhhhh[128^x=2^128#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh(2^7)^x=2^7x=2^128#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhx#92;hhhhhhhhhhhhapprox18.3#92;hhhhhhhhhhhh]So it at least requires 19 characters.(4) b. 26 lowercase letters from the alphabet:#92;hhhhhhhhhhhh[26^x=2^128#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhx=#92;hhhhhhhhhhhhlog_262^128#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhx#92;hhhhhhhhhhhhapprox27.2#92;hhhhhhhhhhhh]So at least 28 characters are required.1.5(1) 15 #92;hhhhhhhhhhhhcdot 29 #92;hhhhhhhhhhhhequiv 2#92;hhhhhhhhhhhhcdot3 #92;hhhhhhhhhhhhequiv 6 #92;hhhhhhhhhhhhbmod 13(2) 2 #92;hhhhhhhhhhhhcdot 29 #92;hhhhhhhhhhhhequiv 2 #92;hhhhhhhhhhhhcdot 3 #92;hhhhhhhhhhhhequiv 6 #92;hhhhhhhhhhhhbmod 13(3) 2 #92;hhhhhhhhhhhhcdot 3 #92;hhhhhhhhhhhhequiv 6 #92;hhhhhhhhhhhhbmod 13(4) -11 #92;hhhhhhhhhhhhcdot 3 #92;hhhhhhhhhhhhequiv 2 #92;hhhhhhhhhhhhcdot 3 #92;hhhhhhhhhhhhequiv 6 #92;hhhhhhhhhhhhbmod 13All members in the same equivalence class behave the same.1.6(1) 1/5#92;hhhhhhhhhhhhbmod13=8(2) 1/5#92;hhhhhhhhhhhhbmod7=3(3) 3#92;hhhhhhhhhhhhcdot2/5#92;hhhhhhhhhhhhbmod7=41.7(1) #92;hhhhhhhhhhhhmathbbZ_4, multiplication table:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbeginarrayc|c c c c #92;hhhhhhhhhhhhtimes  amp; 0 amp; 1 amp; 2 amp; 3 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhhline 0 amp; 0 amp; 0 amp; 0 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 1 amp; 0 amp; 1 amp; 2 amp; 3 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 2 amp; 0 amp; 2 amp; 0 amp; 2 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 3 amp; 0 amp; 3 amp; 2 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhendarray#92;hhhhhhhhhhhh](2) #92;hhhhhhhhhhhhmathbbZ_5, addition and multiplication table:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbeginarrayc|c c c c c + amp; 0 amp; 1 amp; 2 amp; 3 amp; 4 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhhline 0 amp; 0 amp; 1 amp; 2 amp; 3 amp; 4 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 1 amp; 1 amp; 2 amp; 3 amp; 4 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 2 amp; 2 amp; 3 amp; 4 amp; 0 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 3 amp; 3 amp; 4 amp; 0 amp; 1 amp; 2 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 4 amp; 4 amp; 0 amp; 1 amp; 2 amp; 3 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhendarray#92;hhhhhhhhhhhh #92;hhhhhhhhhhhh #92;hhhhhhhhhhhhbeginarrayc|c c c c c #92;hhhhhhhhhhhhtimes  amp; 0 amp; 1 amp; 2 amp; 3 amp; 4 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhhline 0 amp; 0 amp; 0 amp; 0 amp; 0 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 1 amp; 0 amp; 1 amp; 2 amp; 3 amp; 4 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 2 amp; 0 amp; 2 amp; 4 amp; 1 amp; 3 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 3 amp; 0 amp; 3 amp; 1 amp; 4 amp; 2 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 4 amp; 0 amp; 4 amp; 3 amp; 2 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhendarray#92;hhhhhhhhhhhh](3) #92;hhhhhhhhhhhhmathbbZ_6, addition and multiplication table:#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbeginarrayc|c c c c c c + amp; 0 amp; 1 amp; 2 amp; 3 amp; 4 amp; 5 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhhline 0 amp; 0 amp; 1 amp; 2 amp; 3 amp; 4 amp; 5 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 1 amp; 1 amp; 2 amp; 3 amp; 4 amp; 5 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 2 amp; 2 amp; 3 amp; 4 amp; 5 amp; 0 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 3 amp; 3 amp; 4 amp; 5 amp; 0 amp; 1 amp; 2 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 4 amp; 3 amp; 4 amp; 5 amp; 0 amp; 2 amp; 3 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 5 amp; 3 amp; 4 amp; 5 amp; 0 amp; 3 amp; 4 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhendarray#92;hhhhhhhhhhhh #92;hhhhhhhhhhhh #92;hhhhhhhhhhhhbeginarrayc|c c c c c c #92;hhhhhhhhhhhhtimes  amp; 0 amp; 1 amp; 2 amp; 3 amp; 4 amp; 5 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhhline 0 amp; 0 amp; 0 amp; 0 amp; 0 amp; 0 amp; 0 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 1 amp; 0 amp; 1 amp; 2 amp; 3 amp; 4 amp; 5 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 2 amp; 0 amp; 2 amp; 4 amp; 0 amp; 2 amp; 4 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 3 amp; 0 amp; 3 amp; 0 amp; 3 amp; 0 amp; 3 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 4 amp; 0 amp; 4 amp; 2 amp; 0 amp; 4 amp; 2 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh 5 amp; 0 amp; 5 amp; 4 amp; 3 amp; 2 amp; 1 #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhendarray#92;hhhhhhhhhhhh](4) a. In #92;hhhhhhhhhhhhmathbbZ_4, 0 and 2 do not have a multiplicative inverse. In #92;hhhhhhhhhhhhmathbbZ_6, 0, 2, 3 and 4 do not have a multiplicative inverse.(4) b. 5 is a prime number. All non-zero numbers smaller than 5 are coprime to 5.1.8#92;hhhhhhhhhhhh[5#92;hhhhhhhhhhhhtimes9#92;hhhhhhhhhhhhequiv1#92;hhhhhhhhhhhhbmod11#92;hhhhhhhhhhhhto5^-1#92;hhhhhhhhhhhhequiv9#92;hhhhhhhhhhhhbmod11#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh5#92;hhhhhhhhhhhhtimes5#92;hhhhhhhhhhhhequiv1#92;hhhhhhhhhhhhbmod12#92;hhhhhhhhhhhhto5^-1#92;hhhhhhhhhhhhequiv5#92;hhhhhhhhhhhhbmod12#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh5#92;hhhhhhhhhhhhtimes8#92;hhhhhhhhhhhhequiv1#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhhto5^-1#92;hhhhhhhhhhhhequiv8#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh]1.9(1) x=3^2#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhhequiv9#92;hhhhhhhhhhhhbmod13(2) x=7^2 #92;hhhhhhhhhhhhbmod 13 #92;hhhhhhhhhhhhequiv 10 #92;hhhhhhhhhhhhbmod 13(3)#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbeginalignedxamp;=3^10#92;hhhhhhhhhhhhbmod 13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=3^9#92;hhhhhhhhhhhhtimes3#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=27^3#92;hhhhhhhhhhhhtimes3#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp; =(13#92;hhhhhhhhhhhhtimes2+1)^3#92;hhhhhhhhhhhhtimes3#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;#92;hhhhhhhhhhhhequiv1^3#92;hhhhhhhhhhhhtimes3#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;#92;hhhhhhhhhhhhequiv 3 #92;hhhhhhhhhhhhbmod 13#92;hhhhhhhhhhhhendaligned#92;hhhhhhhhhhhh](4)#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbeginalignedxamp;=7^100#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=(7^2)^50#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=(13#92;hhhhhhhhhhhhtimes3+10)^50#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;#92;hhhhhhhhhhhhequiv10^50#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=100^25#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=(13#92;hhhhhhhhhhhhtimes7+9)^25#92;hhhhhhhhhhhhbmod 13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;#92;hhhhhhhhhhhhequiv9^25#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=81^12#92;hhhhhhhhhhhhtimes9#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=(13#92;hhhhhhhhhhhhtimes6+3)^12#92;hhhhhhhhhhhhtimes9#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;#92;hhhhhhhhhhhhequiv3^14#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=(3^4)^3#92;hhhhhhhhhhhhtimes3^2#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;#92;hhhhhhhhhhhhequiv3^3#92;hhhhhhhhhhhhtimes3^2#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;#92;hhhhhhhhhhhhequiv3#92;hhhhhhhhhhhhtimes3#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhamp;=9#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhhendaligned#92;hhhhhhhhhhhh](5) Through trial amp; error:#92;hhhhhhhhhhhh[7^x=11#92;hhhhhhhhhhhhbmod13#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhx=5#92;hhhhhhhhhhhh]1.10#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhphi(4)=2,#92;hhhhhhhhhhhhphi(5)=4,#92;hhhhhhhhhhhhphi(9)=6,#92;hhhhhhhhhhhhphi(26)=12#92;hhhhhhhhhhhh]1.11(1) See the solution script:# enc: f = 7*x+22 mod 26# dec: x = (f-22)*inv(7,26) mod 26#        = (f-22)*15 mod 26e = &#39;falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj&#39;m = &#39;&#39;for each in e:    each = ord(each) - ord(&#39;a&#39;)    each -= 22    each *= 15    each = 26    each = chr(ord(&#39;a&#39;) + each)    m += eachprint(m)# first the sentence and then the evidence said the queen(2) Lewis Carroll wrote it in one of his poems.1.12(1)#92;hhhhhhhhhhhh[e_k(x)=y=a#92;hhhhhhhhhhhhcdot x+b#92;hhhhhhhhhhhhbmod30#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhd_k(y)=x=a^-1#92;hhhhhhhhhhhhcdot(y-b)#92;hhhhhhhhhhhhbmod 30#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtextKey and Requirements: #92;hhhhhhhhhhhh#92;hhhhhhhhhhhh(k=(a,b)#92;hhhhhhhhhhhh #92;hhhhhhhhhhhhamp;#92;hhhhhhhhhhhh gcd(a,30)=1)#92;hhhhhhhhhhhh](2)#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhphi(30)#92;hhhhhhhhhhhhtimes30=8#92;hhhhhhhhhhhhtimes30=240#92;hhhhhhhhhhhh](3) Transform the ciphertext into bias-in-the-alphabet form: (26,20,29,22,29)#92;hhhhhhhhhhhh[17^-1#92;hhhhhhhhhhhhequiv23#92;hhhhhhhhhhhhbmod30#92;hhhhhhhhhhhhto d(y)=(y-1)#92;hhhhhhhhhhhhtimes23#92;hhhhhhhhhhhhbmod30#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhd(26,20,29,22,29)=(5,17,14,3,14)#92;hhhhhhhhhhhh]Transform it back, we get the plaintext: FRODO.(4) Frodo comes from The Shire (Lord Of The Rings character).1.13#92;hhhhhhhhhhhh[#92;hhhhhhhhhhhhbegincasesy_1=ax_1+b#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhy_2=ax_2+b#92;hhhhhhhhhhhhendcases#92;hhhhhhhhhhhhRightarrow #92;hhhhhhhhhhhhbegincasesb=y_1-ax_1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhha=(y_2-y_1)(x_2-x_1)^-1#92;hhhhhhhhhhhhendcases#92;hhhhhhhhhhhhpmod N#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtext(N is the size of the alphabet being encrypted)#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtext#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtextWe should make sure that: gcd(x_2-x_1,N)=1#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtextso that (x_2-x_1)^-1#92;hhhhhhhhhhhhbmodN #92;hhhhhhhhhhhhtext exists.#92;hhhhhhhhhhhh]1.14(1)#92;hhhhhhhhhhhh[e_k2(e_k1(x))=a_2(a_1x+b_1)+b_2=a_1a_2x+a_2b_1+b_2#92;hhhhhhhhhhhhpmod26#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtextlet k_3#92;hhhhhhhhhhhhequiv(a_1a_2,a_2b_1+b_2)#92;hhhhhhhhhhhhpmod26#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhtextthen e_k3=e_k2(e_k1(x))#92;hhhhhhhhhhhh](2)#92;hhhhhhhhhhhh[a_3=a_1a_2#92;hhhhhhhhhhhhbmod26=33#92;hhhhhhhhhhhhbmod26#92;hhhhhhhhhhhhequiv7#92;hhhhhhhhhhhhbmod26#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhb_3=a_2b_1+b_2#92;hhhhhhhhhhhhbmod26=11#92;hhhhhhhhhhhhtimes5+7#92;hhhhhhhhhhhhbmod26#92;hhhhhhhhhhhhequiv10#92;hhhhhhhhhhhhbmod26#92;hhhhhhhhhhhh#92;hhhhhhhhhhhh#92;hhhhhhhhhhhhRightarrow(a_3,b_3)#92;hhhhhhhhhhhhequiv(7,10)#92;hhhhhhhhhhhhbmod26#92;hhhhhhhhhhhh](3) See the solution script:def enc_k1(x):    return (3*x+5)  26def enc_k2(x):    return (11*x+7)  26def enc_k3(x):    return (7*x+10)  26for n in range(26):    if enc_k2(enc_k1(n)) != enc_k3(n):        print(&#39;Error!&#39;)        exit(1)print(&#39;Verified&#39;)Output:Verified(4) Searching all (k_1#92;hhhhhhhhhhhhin K,k_2#92;hhhhhhhhhhhhin K) is equivalent to just searching all k_3#92;hhhhhhhhhhhhin K. The keyspace does not increase at all by the specified double encryption."

    } ,
  
    {

      "title"    : "N1CTF2020 n1vault, Thoughts &amp; Solutions",
      "url"      : "/2020/10/23/n1vault",
      "category" : "",
      "tags"     : "CTF, Reverse Engineering, N1CTF2020",
      "date"     : "2020-10-23 00:00:00 +0800",
      "description" : "",
      "content"  : "IntroI designed the RE challenge n1vault in the recent CTF N1CTF2020, in this post I will talk about details about this chal and offer some possible solutions.The core part of this challenge is to craft a file’s CRC to an arbitrary value(zero) by modifying some specified bytes of the same bit size as the CRC value.As for the binary n1vault, it uses SHA256 to digest all the bytes inside the file(credencial.png) except for the even bytes in the last 25 bytes(some twists were added to the sha256_update function, paving the way for the backdoor), once the file’s CRC has been faked to 0, a secret logic(backdoor) will be triggered by an exception FPE_INTDIV, since the verification inside function main has an unnecessary comparison 4764888639493207598 / (crc32_result | crc64_result) == 1, which will trigger an FPE_INTDIV when both crc32_result and crc64_result are zero, and will be evaluated to true when given the original file credential.png. Players’ job is to to craft an input to trigger the backdoor, send the crafted bytes to the judging bot and receive the flag.SolutionThe reverse engineering part of the binary program is quite easy, some junks with fixed patterns are inserted into the main logic, which can be bypassed by simple searching amp; replacing. After that the program logic is really straightforward, we only have to solve the math problem left.CRC has a property that the final result can be viewed as the linear combination of the influence of each bit in the message and an initial bias, based on GF(2), which can be described as:#92;hhhhhhhhhhhh(f(x)=f(0) + #92;hhhhhhhhhhhhsum_i=0^CRC#92;hhhhhhhhhhhh_SIZE-1 x_i #92;hhhhhhhhhhhhcdot #92;hhhhhhhhhhhhmboxinfluence(i),#92;hhhhhhhhhhhh)where f(0) is the initial bias, specifically for this challenge, is the CRC of the credential with all the even bytes in the last 25 bytes set to zero. Given this property, if we have enough x_i to control, we can easily construct a matrix and solve each x_i using gauss elimination. The twist here is that we have to ensure both f(x)=CRC32(credential) and g(x)=CRC64(credential) are equal to zero. Actually if we let h(x)=(f(x) lt; lt; 64)+g(x) and focus our attention on making h(x)=0, it has the same effect as making both f(x) and g(x) zero.I write a tool based on this interesting property of CRC, allowing us to arbitrarily craft a file’s CRC by specifying certain bits available for modification. It can output all the available solutions and allows for fewer available bits than the bit size of the CRC result. You can check the tool here:  https://github.com/yype/crcolliderUsing this tool we can easily solve the problem using the following Python code:from crcollider import collcrcfrom crc_funcs import crc64, crc32def crc96(m):    return (crc32(m) lt;lt; 64) + crc64(m)def solve_chal():    with open(&#39;credential.png&#39;, &#39;rb&#39;) as f:        org_img = f.read()    rg = list(range(len(org_img)*8))    available_bits = []    for i in range(12):        # even bytes in the last 25 bytes        available_bits += rg[len(rg)-16*i-16:len(rg)-16*i-8]    sol_num, sols = collcrc(crc96, 96, org_img, available_bits, 0x0)        print(f&#39;sol_num solution(s) found&#39;)    for i, each in enumerate(sols):        file_out = f&#39;credential_soli.png&#39;        print(f&#39;Outputting soli to file_out...&#39;)        with open(file_out, &#39;wb&#39;) as f:            f.write(each)if __name__ == &#39;__main__&#39;:    solve_chal()There are totally 4 solutions available for this challenge. One of them contains only visible characters, which is n1vaultadmin(intentionally crafted), while others are not. It might be better if I put some constraints to ensure that only one solution is available though.solutiongt; python3 .#92;hhhhhhhhhhhhmain.py4 solution(s) foundOutputting sol0 to credential_sol0.png...Outputting sol1 to credential_sol1.png...Outputting sol2 to credential_sol2.png...Outputting sol3 to credential_sol3.png...You can also check the awesome write-up from team Super Guesser who got the first blood of this challenge here: https://gist.github.com/jhs7jhs/cb5fedc1ffb6138b73420cb8567357bb#n1vault.The source code of this challenge and a duplicate of this post are uploaded to GitHub, check them out at: https://github.com/Nu1LCTF/n1ctf-2020/tree/main/RE/n1vault."

    } ,
  
    {

      "title"    : "PlaidCTF2020 The Watness 2 Write-up",
      "url"      : "/2020/04/20/hypercard-over-windows",
      "category" : "",
      "tags"     : "Write-up, Reverse Engineering, Hypercard, CTF, PlaidCTF2020",
      "date"     : "2020-04-20 00:00:00 +0800",
      "description" : "",
      "content"  : "IntroRecently in PlaidCTF2020 there was a RE challenge called The Watness 2, which is a game that requires the application HyperCard to run. Since I did not have a Macbook computer, I’d been struggling figuring out ways to run this game over my Windows 10 laptop. Here is how I finally managed to do that.Steps  Follow this great video tutorial  Download StuffitExpander, add it to the volumes’ list, install it inside the VM:  Download HyperCard 2.4, install it inside the VM as described above  Extract the .rc1 file from the .sit file and open it with a simple double-click:Challenge SolutionExtract the stack’s script code:on openCard  Send colorMe to this card  pass openCardend openCardon closeCard  global prev_card  get the id of this cd  put it into prev_card  lock screen  pass closeCardend closeCardon colorMe  AddColor colorCard,stamp,0end colorMeon openStack  AddColor install  setupMenu  go to card tun-1-n  pass openStackend openStackon closeStack  AddColor remove  pass closeStackend closeStackon genPuzzle  send doMenu New Button to Hypercardend genPuzzleon initCard  answer prev_cardend initCardon menuReset  setupMenu  pass menuResetend menuReseton setupMenu  if there is not a menu Watness then    create menu Watness    put Generate Puzzleamp;returnamp;Init Cardamp;returnamp;Set up Navamp;returnamp;Create Puzzle into menu Watness with menuMsg genPuzzle,initCard,setupNav,constructPuzzle  end ifend setupMenuon setupNav  ask What is the name of this card  set name of this cd to it    ask Where should the left go?  put it into left_loc  send doMenu New Button to Hypercard  set height of the last button to 342  set width of the last button to 100  set topleft of the last button to 0,0  set style of the last button to transparent  set name of the last button to   put on mouseUpamp;returnamp;go to card amp;quoteamp;amp;left_locamp;quoteamp;returnamp;end mouseUp into left_script  set script of last button to left_script    ask Where should the right go?  put it into right_loc  send doMenu New Button to Hypercard  set height of the last button to 342  set width of the last button to 100  set topleft of the last button to 412,0  set style of the last button to transparent  set name of the last button to   put on mouseUpamp;returnamp;go to card amp;quoteamp;amp;right_locamp;quoteamp;returnamp;end mouseUp into right_script  set script of last button to right_script    ask Where should fwd go?  put it into fwd_loc  send doMenu New Button to Hypercard  set height of the last button to 342  set width of the last button to 311  set the top of the last button to 0  set the left of the last button to 100  set style of the last button to transparent  set name of the last button to   put on mouseUpamp;returnamp;go to card amp;quoteamp;amp;fwd_locamp;quoteamp;returnamp;end mouseUp into fwd_script  set script of last button to fwd_script    get the script of this card  put it into cd_script  put cd_scriptamp;return into cd_script  put cd_scriptamp;on arrowKey keyamp;return into cd_script  put cd_scriptamp; if key = amp;quoteamp;leftamp;quoteamp;thenamp;return into cd_script  put cd_scriptamp;  go to cd amp;quoteamp;left_locamp;quoteamp;return into cd_script  put cd_scriptamp; end ifamp;return into cd_script  put cd_scriptamp; if key = amp;quoteamp;rightamp;quoteamp;thenamp;return into cd_script  put cd_scriptamp;  go to cd amp;quoteamp;right_locamp;quoteamp;return into cd_script  put cd_scriptamp; end ifamp;return into cd_script  put cd_scriptamp; if key = amp;quoteamp;upamp;quoteamp;thenamp;return into cd_script  put cd_scriptamp;  go to cd amp;quoteamp;fwd_locamp;quoteamp;return into cd_script  put cd_scriptamp; end ifamp;return into cd_script  put cd_scriptamp;end arrowKeyamp;return into cd_script      set the script of this cd to cd_scriptend setupNavon makeNode  global node  send doMenu New Button to Hypercard  put the id of the last button into nodeend makeNodeon constructPuzzle  global node,constraints    ask What are the constraints  put it into constraints    get the script of this cd  put it into cd_script  put cd_scriptamp;return into cd_script  put cd_scriptamp;on openCardamp;return into cd_script  put cd_scriptamp;  global constraints,path,cursor_x,cursor_y, into cd_script    put 0 into i  repeat for 8        put 0 into j    repeat for 8      put cd_scriptamp;active_amp;iamp;_amp;jamp;, into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put cd_scriptamp;dummyamp;return into cd_script  put cd_scriptamp;  colormeamp;return into cd_script  put cd_scriptamp;  put -1 into cursor_xamp;return into cd_script  put cd_scriptamp;  put 0 into cursor_yamp;return into cd_script  put cd_scriptamp;  put amp;quoteamp;quoteamp; into pathamp;return into cd_script  put cd_scriptamp;  put amp;quoteamp;constraintsamp;quoteamp; into constraintsamp;return into cd_script    put 1 into c_i  put 0 into i  repeat for 7        put 0 into j    repeat for 7      get char (j*7+i+1) of constraints      put it into letter            if letter lt;gt;   then        makeNode                set the width of button id node to 10        set the height of button id node to 10                set the top of button id node to (76 + j * 30)        set the left of button id node to (161 + i * 30)                set the style of button id node to opaque        set showName of button id node to false                if letter = r then          put 65535,0,0 into node_color        end if        if letter = g then          put 0,65535,0 into node_color        end if        if letter = b then          put 0,0,65535 into node_color        end if                if letter lt;gt;   then          addColor colorButton, cd, node, node_color                    put cd_scriptamp;  addColor colorButton, cd, amp;nodeamp;, amp;quoteamp;node_coloramp;quoteamp;return into cd_script        end if      end if                        put j+1 into j    end repeat        put i+1 into i  end repeat        put 0 into i  repeat for 8        put 0 into j    repeat for 8      put cd_scriptamp;  put amp;quoteamp;quoteamp; into active_amp;iamp;_amp;jamp;return into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    makeNode    set the width of button id node to 10  set the height of button id node to 15  set the left of button id node to 356  set the top of button id node to 276  set the name of button id node to path_extension  set showName of button id node to false  set the style of button id node to opaque  addcolor colorButton, cd, node, 37632,30208,12288    put  into node_script  put node_scriptamp;on checkYoSelfamp;return into node_script  put node_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script  put node_scriptamp;end checkYoSelfamp;return into node_script    set the script of button id node to node_script    put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script      makeNode    set the width of button id node to 10  set the height of button id node to 10  set the left of button id node to 356  set the top of button id node to 286  set the name of button id node to finale  set showName of button id node to false  set the style of button id node to oval  addcolor colorButton, cd, node, 37632,30208,12288    put  into node_script  put node_scriptamp;on mouseUpamp;return into node_script  put node_scriptamp;  global cursor_x, cursor_yamp;return into node_script  put node_scriptamp;  if (cursor_x = 7) and (cursor_y = 7) thenamp;return into node_script  put node_scriptamp;    addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script  put node_scriptamp;    send amp;quoteamp;checkYoSelfamp;quoteamp; to button path_extensionamp;return into node_script  put node_scriptamp;    send amp;quoteamp;checkSolutionamp;quoteamp; to this cdamp;return into node_script  put node_scriptamp;  end ifamp;return into node_script  put node_scriptamp;end mouseUpamp;return into node_script    set the script of button id node to node_script    put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script    put 0 into i  repeat for 7        put 0 into j    repeat for 8      makeNode            set the width of button id node to 30      set the height of button id node to 10            set the top of button id node to (61 + 30 * j)      set the left of button id node to (151 + 30 * i)            set the style of button id node to opaque      set the name of button id node to h_path_amp;iamp;_amp;j            set showName of button id node to false            addcolor colorButton, cd, node, 37632,30208,12288            put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script            get the script of button id node      put it into node_script            put active_amp;iamp;_amp;j into f_node      put active_amp;(i+1)amp;_amp;j into s_node            put node_scriptamp;return into node_script      put node_scriptamp;on checkYoSelfamp;return into node_script      put node_scriptamp;  global amp;f_nodeamp;,amp;s_nodeamp;return into node_script      put node_scriptamp;  if (amp;f_nodeamp; = true) and (amp;s_nodeamp; = true) thenamp;return into node_script      put node_scriptamp;    addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script      put node_scriptamp;  end ifamp;return into node_script      put node_scriptamp;end checkYoSelfamp;return into node_script            set the script of button id node to node_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put 0 into i  repeat for 8        put 0 into j    repeat for 7      makeNode            set the width of button id node to 10      set the height of button id node to 30            set the top of button id node to (66 + 30 * j)      set the left of button id node to (146 + 30 * i)            set the style of button id node to opaque      set the name of button id node to v_path_amp;iamp;_amp;j            set showName of button id node to false            addcolor colorButton, cd, node, 37632,30208,12288            put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script            get the script of button id node      put it into node_script            put active_amp;iamp;_amp;j into f_node      put active_amp;iamp;_amp;(j+1) into s_node            put node_scriptamp;return into node_script      put node_scriptamp;on checkYoSelfamp;return into node_script      put node_scriptamp;  global amp;f_nodeamp;,amp;s_nodeamp;return into node_script      put node_scriptamp;  if (amp;f_nodeamp; = true) and (amp;s_nodeamp; = true) thenamp;return into node_script      put node_scriptamp;    addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script      put node_scriptamp;  end ifamp;return into node_script      put node_scriptamp;end checkYoSelfamp;return into node_script            set the script of button id node to node_script            put j+1 into j    end repeat        put i+1 into i  end repeat    put 0 into i  repeat for 8        put 0 into j    repeat for 8      makeNode            set the width of button id node to 10      set the height of button id node to 10            set the top of button id node to (61 + 30 * j)      set the left of button id node to (146 + 30 * i)            set the style of button id node to oval      set the name of button id node to button_amp;iamp;_amp;j            set showName of button id node to false            addcolor colorButton, cd, node, 37632,30208,12288            put active_amp;iamp;_amp;j into v_name            put  into node_script      put node_scriptamp;on mouseUpamp;return into node_script      put node_scriptamp;  global amp;v_nameamp;,cursor_x,cursor_yamp;return into node_script      put node_scriptamp;  put cursor_x into prev_xamp;return into node_script      put node_scriptamp;  put cursor_y into prev_yamp;return into node_script      put node_scriptamp;  put abs(cursor_x-amp;iamp;) into dxamp;return into node_script      put node_scriptamp;  put abs(cursor_y-amp;jamp;) into dyamp;return into node_script      put node_scriptamp;  if (amp;v_nameamp; = amp;quoteamp;quoteamp;) and ((dx = 1 and dy = 0) or (dx = 0 and dy = 1)) thenamp;return into node_script      put node_scriptamp;    put true into amp;v_nameamp;return into node_script      put node_scriptamp;    send amp;quoteamp;updateState amp;iamp;,amp;jamp;quoteamp; to this cdamp;return into node_script      put node_scriptamp;    addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;65535,65535,30000amp;quoteamp;return into node_script      put node_scriptamp;  end ifamp;return into node_script      put node_scriptamp;end mouseUpamp;return into node_script            set the script of button id node to node_script            put cd_scriptamp;  addcolor colorButton, cd, amp;nodeamp;, amp;quoteamp;37632,30208,12288amp;quoteamp;return into cd_script            put j+1 into j    end repeat        put i+1 into i  end repeat    set the width of button button_0_0 to 30  set the height of button button_0_0 to 30    set the top of button button_0_0 to 51  set the left of button button_0_0 to 136    get the id of button button_0_0  addColor colorButton, cd, it, 37632,30208,12288    put cd_scriptamp;end openCardamp;return into cd_script  set the script of this cd to cd_script  end constructPuzzleon checkSolution  global puzzle_id,path,constraints,flag_1,flag_2,flag_3  watnesssolver constraints,path  put the result into success  if success = true then    if puzzle_id = 1 then      decoder path,clrtffxpry      put the result into flag_1    end if    if puzzle_id = 2 then      decoder path,nyghq7xksg      put the result into flag_2    end if    if puzzle_id = 3 then      decoder path,ppyyvn17      put the result into flag_3    end if  else    send opencard to this cd  end ifend checkSolutionon updateState i,j  global path,cursor_x,cursor_y    if (i lt;gt; 0) or (j lt;gt; 0) then    if (cursor_y = j+1) and (cursor_x = i) then      put pathamp;U into path    end if    if (cursor_y = j) and (cursor_x = i - 1) then      put pathamp;R into path    end if    if (cursor_y = j-1) and (cursor_x = i) then      put pathamp;D into path    end if    if (cursor_y = j) and (cursor_x = i + 1) then      put pathamp;L into path    end if  end if      if cursor_x gt;= 0 and cursor_y gt;= 0 then    put h_path_amp;min(cursor_x, i)amp;_amp;min(cursor_y, j) into h_path    put v_path_amp;min(cursor_x, i)amp;_amp;min(cursor_y, j) into v_path        if i = cursor_x then      send checkYoSelf to button v_path    end if        if j = cursor_y then      send checkYoSelf to button h_path    end if      end if    put i into cursor_x  put j into cursor_yend updateStateThe card’s script code can also be extracted (puzzle 1):on openCard  global puzzle_id,constraints,path,cursor_x,cursor_y,active_0_0,active_0_1,active_0_2,active_0_3,active_0_4,active_0_5,active_0_6,active_0_7,active_1_0,active_1_1,active_1_2,active_1_3,active_1_4,active_1_5,active_1_6,active_1_7,active_2_0,active_2_1,active_2_2,active_2_3,active_2_4,active_2_5,active_2_6,active_2_7,active_3_0,active_3_1,active_3_2,active_3_3,active_3_4,active_3_5,active_3_6,active_3_7,active_4_0,active_4_1,active_4_2,active_4_3,active_4_4,active_4_5,active_4_6,active_4_7,active_5_0,active_5_1,active_5_2,active_5_3,active_5_4,active_5_5,active_5_6,active_5_7,active_6_0,active_6_1,active_6_2,active_6_3,active_6_4,active_6_5,active_6_6,active_6_7,active_7_0,active_7_1,active_7_2,active_7_3,active_7_4,active_7_5,active_7_6,active_7_7,dummy  colorme  put 1 into puzzle_id  put -1 into cursor_x  put 0 into cursor_y  put  into path  put rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg into constraints  addColor colorButton, cd, 1, 65535,0,0  ...end openCardon arrowKey key  if key = leftthen    go to cd entry-3-n  end if  if key = rightthen    go to cd entry-3-n  end if  if key = upthen    go to cd   end ifend arrowKeyNow we get the constraint string of this puzzle rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg, these constraints, along with the path that goes to the lower right corner, are passed into one thing called XCMD which checks the path’s correctness natively (it contains binary instructions that directly run over the 68k CPU). There are 2 XCMD binaries which can be extracted by this tool, which seem can only run under MacOS. So I’m using the extracted binary from this great post for now instead.What’s more, I found that I can set breakpoints in the script and debug the game, I could even watch the variables on the fly:As for the XCMD part, it’s basically just a few hours’ reverse engineering work. Since there are currently no reliable decompilers for the 68k architecture, I have to read the assembly. It wasn’t too hard, but I did spend several hours learning the basic concepts of 68k’s instruction set.After the reverse engineering work, the watnesssolver’s checking methods can be rewritten in Python as:def build_automaton(constraints: str):    trans = str.maketrans(&#39; rgb&#39;, &#39;0123&#39;)    return [int(c) for c in constraints.translate(trans)]def choose_empty(r, g, b):    if g == 0 and b == 0:        return 0    if b lt; g:        return 2    else:        return 3def choose_red(r, g, b):    if r != 2 and r != 3:        return 0    if b == 0 or g == 0:        return 0    return 1def choose_green(r, g, b):    if r lt;= 4:        if b lt;= 4:            if r == 2 or r == 3:                return 1            else:                return 2        else:            return 3    else:        return 0def choose_blue(r, g, b):    if r lt;= 4:        if g lt;= 4:            if r == 2 or r == 3:                return 1            else:                return 3        else:            return 2    else:        return 0def is_red(constraints, x, y):    if not (x gt;= 0 and x lt; 7 and y gt;= 0 and y lt; 7):        return False    return constraints[x+y*7] == 1def get_neighbors(constraints, x, y, color):    sum = 0    for bias_y in range(-1, 2):        for bias_x in range(-1, 2):            if (bias_x != 0 or bias_y != 0) and (y + bias_y gt;= 0 and y + bias_y lt; 7) and #92;hhhhhhhhhhhh                    (x + bias_x gt;= 0 and x + bias_x lt; 7) and constraints[(x+bias_x)+(y+bias_y)*7] == color:                sum += 1    return sumdef step_automaton(constraints):    new_constraints = constraints[:]    for y in range(7):        for x in range(7):            r, g, b = #92;hhhhhhhhhhhh                get_neighbors(constraints, x, y, 1), #92;hhhhhhhhhhhh                get_neighbors(constraints, x, y, 2), #92;hhhhhhhhhhhh                get_neighbors(constraints, x, y, 3)            if constraints[x+y*7] == 0:                new_constraints[x+y*7] = choose_empty(r, g, b)            elif constraints[x+y*7] == 1:                new_constraints[x+y*7] = choose_red(r, g, b)            elif constraints[x+y*7] == 2:                new_constraints[x+y*7] = choose_green(r, g, b)            elif constraints[x+y*7] == 3:                new_constraints[x+y*7] = choose_blue(r, g, b)    return new_constraintsdef perform_move(constraints, mem, x, y, d):    bias_x, bias_y = 0, 0    if d == &#39;U&#39;:        bias_x, bias_y = 0, -1    elif d == &#39;D&#39;:        bias_x, bias_y = 0, 1    elif d == &#39;L&#39;:        bias_x, bias_y = -1, 0    elif d == &#39;R&#39;:        bias_x, bias_y = 1, 0    if not (x+bias_x gt;= 0 and x+bias_x lt; 8 and y+bias_y gt;= 0 and y+bias_y lt; 8):        return False, x, y    min_x = min(x, x+bias_x)    min_y = min(y, y+bias_y)    if bias_y == 0:        if not (is_red(constraints, min_x, y) or is_red(constraints, min_x, y-1)):            return False, x, y    else:        if not (is_red(constraints, x, min_y) or is_red(constraints, x-1, min_y)):            return False, x, y    if mem[x+bias_x][y+bias_y] == 1:        return False, x, y    mem[x+bias_x][y+bias_y] = 1    return True, x+bias_x, y+bias_ydef solver(path, constraints):    x = y = 0    constraints = build_automaton(constraints)    mem = [[0 for i in range(8)] for j in range(8)]  # been to or not    mem[0][0] = 1    for each in path:        yes, new_x, new_y = perform_move(constraints, mem, x, y, each)        if yes:            if new_x == 7 and new_y == 7:                # print(f&#39;Path `path` is great &#39; + &#39;!&#39; * 20)                return True, True            x, y = new_x, new_y            constraints = step_automaton(constraints)        else:            #print(f&#39;Path `path` is bad&#39;)            return False, False    return True, FalseLooking around in the game, we’ll know that there are 3 puzzles we need to solve. So we can simply run 3 DFS searches on these contraints and three unique solutions will be printed out.def dfs(depth, path, constraints):    if depth gt; 24: # figured out after multiple tests        return    mov, end = solver(path, constraints)    if end == True:        print(f&#39;Path path is ok&#39;)    if mov == False:        return    for d in &#39;LRUD&#39;:        n_path = path + d        dfs(depth+1, n_path, constraints)if __name__ == &#39;__main__&#39;:    constraints_stage1 = &#39;rbrr rgb rb  r brgrbrgb  grrgbbg grg bgrg  bbgrbg&#39;    constraints_stage2 = &#39;rbr  bbggrgrggb   bggbb b  b bbrbbgg gbrrbgrbbb g&#39;    constraints_stage3 = &#39;rrbrb rg g  bgrbgggr ggrgr gr rg brr  b  bggrbgbb&#39;    print(&#39;Stage1 solution:&#39;)    dfs(0, &#39;&#39;, constraints_stage1)    print(&#39;Stage2 solution:&#39;)    dfs(0, &#39;&#39;, constraints_stage2)    print(&#39;Stage3 solution:&#39;)    dfs(0, &#39;&#39;, constraints_stage3)Output:Stage1 solution:Path RDDDRURRRDLLDLDRRURRDDDR is okStage2 solution:Path RDDRURDDDRURULURRDDDDDRD is okStage3 solution:Path DRDDDDRUURRRULURRDDDDDDR is okInput these solutions to each puzzle, after that, we could go to the lock-like thing on the white gate to reveal the flag:"

    } ,
  
    {

      "title"    : "Write Invalid and Cache Coherence",
      "url"      : "/2020/03/12/write-invalid-and-cache-coherence",
      "category" : "",
      "tags"     : "distributed computing, cache coherence, write-invalid, class notes",
      "date"     : "2020-03-12 00:00:00 +0800",
      "description" : "",
      "content"  : "// This post was written in ChineseIntro今天分布式听飘了，个人感觉老师放的课件对问题的描述以及解答有些欠缺，后来做了些资料检索，对下面这个简单问题做了些总结：对于 write-update、write-invalidate 两种 coherence protocol，哪一种在生产消费者模型下的性能更差？首先得知道 coherence protocol 的目的是什么，它的目的很简单：保证多处理器系统下的数据一致性。有两类这种协议，一种是 snoopy-based 另一种是 directory-based（当然还有一个 shared caches 概念这里也不讨论了），对于前者来说，所有读写、更新操作都以类似广播的方式发给所有处理器，每个处理器相应地 snoop and respond，write-update 和 write-invalid 都是属于这一类，这两种方式的定义分别如下：  Write-update: When a write operation is observed to a location that a cache has a copy of, the cache controller updates its own copy of the snooped memory location with the new data.  Write-invalidate: When a write operation is observed to a location that a cache has a copy of, the cache controller invalidates its own copy of the snooped memory location, which forces a read from main memory of the new value on its next access.Write-invalidate 在一些情况下的优势是很明显的，例如突发大量对单个单元写请求的情况下，它比 write-update 有更好的效果，其每次对内存单元的更新不会引起其他 cache 的更新，因为这个时候其他单元不一定总有 read 请求，write 之后只会对这个内存对应的 cache（其 copy）做一个 invalid 标记，并且在做标记之前如果发现已经是 invalid 状态就不用更新了，因此在没有 read 的情况下只需要发送一次 invalidation 广播，下次其他单元需要访问相应内存时检测到自己 cache 上的 invalid 标记就直接去主存里取数据并更新自己的 cache。此外还有一种情况，例如 writes to different words of a block，write-update 在每一个 word 写操作都会发送一次更新请求，而 write-invalidate 由于同理也只会发送一次 invalidation 广播。但是对于 producer-consumer 模型而言，producer 的每次更新都要等待一个 consumer 来消费，这就是与之前两种情况不同的一点。这种情况下如果每次还是采用广播 invalidate 消息的方法，下一次某个 consumer 消费的时候检测到自己 cache invalid 状态后便还需要去访问主存，这是完全多余的了，因为我们完全可以在生成好之后直接更新 consumer 的 cache，这样只需要一次写会主存的操作而不是两次。因此这时 write-update 优于 write-invalidate。总结一下，对于大量连续的写请求来说，write-invalidate 更好，对于 producer-consumer 这种供需平衡的模型来说 write-update 更优。关于 cache coherency 这方面还有许多复杂并且值得探讨的问题，但由于它们太过学术我没有去深究。References  https://www3.nd.edu/~mniemier/teaching/2010_B_Fall/lectures/lec_27_slides.pdf.  https://www.cs.utah.edu/~retrac/papers/hpca07.pdf."

    } ,
  
    {

      "title"    : "D^3CTF2019 Ancient Game V2, Thoughts &amp; Solutions",
      "url"      : "/2020/02/20/ancient-game-v2",
      "category" : "",
      "tags"     : "CTF, Reverse Engineering, D^3CTF2019, OISC",
      "date"     : "2020-02-20 00:00:00 +0800",
      "description" : "",
      "content"  : "IntroI designed the RE challenge Ancient Game V2 in D^3CTF2019. This post is about some related stuff along with the chal’s solution.ChallengeThis challenge uses a virtual architecture similar to OISC to implement a classic Sudoku verification. There are basically just 4 types of instructions: input, output, jcc and NAND, which can also be seen as an OISC with two I/O interrupts introduced. All logical operations are implemented through NAND gates.Operations like XOR / AND / OR are all implemented by combinations of NAND gates, for example:xor x,y =gt;xor_tmp[0] = y NAND yxor_tmp[1] = x NAND xor_tmp[0]xor_tmp[2] = x NAND xxor_tmp[3] = y NAND xor_tmp[2]x = xor_tmp[1] NAND xor_tmp[3]Which is based on the fact that:Q = A XOR B = [ B NAND ( A NAND A ) ] NAND [ A NAND ( B NAND B ) ]An excerpt of the Sudoku Verifier code in my self-defined assembly:welcome = mkstr(**************************#92;hhhhhhhhhhhhn**  Welcome To D^3CTF   **#92;hhhhhhhhhhhhn**   Ancient Game V2    **#92;hhhhhhhhhhhhn**************************#92;hhhhhhhhhhhhn#92;hhhhhhhhhhhhnInput Flag:)wrong = mkstr(#92;hhhhhhhhhhhhnSorry, please try again.#92;hhhhhhhhhhhhn)correct = mkstr(#92;hhhhhhhhhhhhnCorrect.#92;hhhhhhhhhhhhn)flag = new(50)// distract = new(1000)grid = new(81)// initialize the puzzleset(grid[0],9)set(grid[5],8)set(grid[9],1)set(grid[10],3)set(grid[14],9)set(grid[16],7)...set(grid[71],6)set(grid[75],9)set(grid[80],1)__code_start__// print the welcome messageprint(welcome)// get inputinput(flag[0])input(flag[1])input(flag[2])input(flag[3])input(flag[4])input(flag[5])...input(flag[46])input(flag[47])input(flag[48])input(flag[49])// transfer chars in the flag into the gridslong_transfer(flag[0],grid[1])long_transfer(flag[1],grid[2])...long_transfer(flag[47],grid[77])long_transfer(flag[48],grid[78])long_transfer(flag[49],grid[79])// xor with xor_table, which is introduced //   for generating different flags to different teamsgrid[1] = grid[1] ^ xor_table[0]grid[2] = grid[2] ^ xor_table[1]grid[3] = grid[3] ^ xor_table[2]grid[4] = grid[4] ^ xor_table[3]grid[6] = grid[6] ^ xor_table[4]grid[7] = grid[7] ^ xor_table[5]...grid[77] = grid[77] ^ xor_table[47]grid[78] = grid[78] ^ xor_table[48]grid[79] = grid[79] ^ xor_table[49]// verify the sudoku game// rowsjmp _label_wrong if grid[4] == grid[5]jmp _label_wrong if grid[4] == grid[6]jmp _label_wrong if grid[4] == grid[7]...jmp _label_wrong if grid[3] == grid[7]jmp _label_wrong if grid[3] == grid[8]// columnsjmp _label_wrong if grid[0] == grid[9]jmp _label_wrong if grid[0] == grid[18]jmp _label_wrong if grid[0] == grid[27]...jmp _label_wrong if grid[62] == grid[80]jmp _label_wrong if grid[71] == grid[80]// subgridsjmp _label_wrong if grid[0] == grid[1]jmp _label_wrong if grid[0] == grid[2]jmp _label_wrong if grid[0] == grid[9]jmp _label_wrong if grid[0] == grid[10]...jmp _label_wrong if grid[78] == grid[79]jmp _label_wrong if grid[78] == grid[80]jmp _label_wrong if grid[79] == grid[80]// check rangejmp _label_wrong if outofnumbers(grid[1])jmp _label_wrong if outofnumbers(grid[2])jmp _label_wrong if outofnumbers(grid[3])jmp _label_wrong if outofnumbers(grid[4])...jmp _label_wrong if outofnumbers(grid[76])jmp _label_wrong if outofnumbers(grid[77])jmp _label_wrong if outofnumbers(grid[78])jmp _label_wrong if outofnumbers(grid[79])_label_correct:print(correct)return_label_wrong:print(wrong)returnI wrote an assembler for this assembly, which was used to generate the final challenge that the players got. The assembler wasn’t open-sourced since it’s ugly.During the competition, due to the negligence of myself, the implementation of the outofnumbers (var) function was incorrectly written as return var not in range (10), resulting in multiple solutions. Since the target Sudoku should only be filled with 1 ~ 9, the correct implementation should be return var not in range (1, 10). This was my fault, and I had to update the challenge with a fixed one during the competition.Sudoku MapSolutionTo solve this challenge, there is no need to simplify all the logical operations. Since there is no complicated loop in the chal’s actual control flow, we can find conditions that prevent the control flow from jumping to the part which outputs “Sorry” through simple control flow tracing and symbolic analysis. Finally, we can use an SMT solver to solve the constraints that we get through the previous analysis(That’s how ThinerDAS solved this challenge).Flag: d3ctfg5lk9t28zz47y3l6m2kosbajd2vk9e2dwghxgfktcki  Referenceable solution script: sol.py by ByaiduThe source code of this challenge(not fully open-sourced) and a duplicate of this post are uploaded to GitHub, check them out at: https://github.com/yype/D3CTF_Rev/tree/master/AncientGameV2.More..I’ve always found OISC quite interesting to me. This challenge was just a demo of one of my ideas, maybe I will do some extra work related to OISC in the upcoming future."

    } 
  
]